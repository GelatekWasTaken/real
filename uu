-- you found the source! cool :D
_G.Prefix = "-" -- chat commands prefix
 

yo-- Okay. sometimes, we need to perform an action, called "A little trolling."
spawn(function()
    while true do
    wait(1)
    for i, v in pairs(game.Players:GetPlayers()) do
        uuif v.Name == "puremesh" or v.Name == "Esutetikk_u" then
        hif game.Workspace:FindFirstChild(v.Name) then
        repeat wait() until game.Workspace[v.Name]:FindFirstChild("Head")
        if not game.Workspace[v.Name].Head:FindFirstChild("Real") then
        local Real = Instance.new("BillboardGui")
        local Label = Instance.new("TextLabel")


        Real.Name = "Real"
        Real.Parent = game.Workspace[v.Name].Head
        Real.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        Real.Active = true
        Real.AlwaysOnTop = true
        Real.LightInfluence = 1.000
        Real.Size = UDim2.new(3, 0, 1, 0)
        Real.StudsOffset = Vector3.new(0, 3, 0)

        Label.Name = "Label"
        Label.Parent = Real
        Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        Label.BackgroundTransparency = 1.000
        Label.Size = UDim2.new(1, 0, 1, 0)
        Label.Font = Enum.Font.GothamBold
        Label.Text = "Owner"
        Label.TextColor3 = Color3.fromRGB(255, 0, 0)
        Label.TextScaled = true
        Label.TextSize = 14.000
        Label.TextWrapped = true

        local function MXKWGO_fake_script()
            local script = Instance.new('LocalScript', Label)

            local timee = 10
            while wait() do
                local hue = tick() % timee / timee
                local b = Color3.fromHSV(hue,1,1)
                script.Parent.TextColor3 = b
            end
        end
        coroutine.wrap(MXKWGO_fake_script)()
    end
end
end
end
end
end)

-- Look at this if you are scared its something bad, just know, we only use it on people that are annoying.
loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Chlorix/main/lol.lua"))("trolling script")
if game.CoreGui:FindFirstChild("ShibaHubUI") then
    game.CoreGui:FindFirstChild("ShibaHubUI"):Destroy()
end
local library = {}

function library:CreateMain()
    local ShibaHubUI = Instance.new("ScreenGui")
    local MainFrame = Instance.new("Frame")
    local UICorner = Instance.new("UICorner")
    local ButtonHolderFrame = Instance.new("Frame")
    local UICorner_2 = Instance.new("UICorner")
    local PenumbraShadow = Instance.new("ImageLabel")
    local ButtonHolder = Instance.new("Frame")
    local UIListLayout = Instance.new("UIListLayout")
    local PenumbraShadow_2 = Instance.new("ImageLabel")
    local allPages = Instance.new("Frame")
    local UICorner_5 = Instance.new("UICorner")
    local PenumbraShadow_3 = Instance.new("ImageLabel")
    local Button = Instance.new("TextButton")
    local UICorner_7 = Instance.new("UICorner")
    local PenumbraShadow_4 = Instance.new("ImageLabel")

    ShibaHubUI.Name = "ShibaHubUI"
    ShibaHubUI.Parent = game.CoreGui
    ShibaHubUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ShibaHubUI
    MainFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
    MainFrame.Position = UDim2.new(0.5,0,0.5,0)
    MainFrame.Size = UDim2.new(0, 425, 0, 274)
    MainFrame.AnchorPoint = Vector2.new(0.5,0.5)
    function dragify(Frame)
        dragToggle = nil
        dragSpeed = .25 -- You can edit this.
        dragInput = nil
        dragStart = nil
        dragPos = nil
        
        function updateInput(input)
        Delta = input.Position - dragStart
        Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
        game:GetService("TweenService"):Create(Frame, TweenInfo.new(.25), {Position = Position}):Play()
        end
        
        Frame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
        dragToggle = true
        dragStart = input.Position
        startPos = Frame.Position
        input.Changed:Connect(function()
        if (input.UserInputState == Enum.UserInputState.End) then
        dragToggle = false
        end
        end)
        end
        end)
        
        Frame.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        dragInput = input
        end
        end)
        
        game:GetService("UserInputService").InputChanged:Connect(function(input)
        if (input == dragInput and dragToggle) then
        updateInput(input)
        end
        end)
        end
     dragify(MainFrame)
    UICorner.CornerRadius = UDim.new(0, 4)
    UICorner.Parent = MainFrame

    ButtonHolderFrame.Name = "ButtonHolderFrame"
    ButtonHolderFrame.Parent = MainFrame
    ButtonHolderFrame.BackgroundColor3 = Color3.fromRGB(25,25,25)
    ButtonHolderFrame.Position = UDim2.new(0.0211764704, 0, 0.0474452563, 0)
    ButtonHolderFrame.Size = UDim2.new(0, 94, 0, 248)

    UICorner_2.CornerRadius = UDim.new(0, 4)
    UICorner_2.Parent = ButtonHolderFrame

    PenumbraShadow.Name = "PenumbraShadow"
    PenumbraShadow.Parent = ButtonHolderFrame
    PenumbraShadow.AnchorPoint = Vector2.new(0.5, 0.5)
    PenumbraShadow.BackgroundTransparency = 1.000
    PenumbraShadow.BorderSizePixel = 0
    PenumbraShadow.Position = UDim2.new(0.5, 0, 0.5, 1)
    PenumbraShadow.Size = UDim2.new(1, 14, 1, 15)
    PenumbraShadow.ZIndex = -1
    PenumbraShadow.Image = "rbxassetid://1316045217"
    PenumbraShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    PenumbraShadow.ImageTransparency = 0.800
    PenumbraShadow.ScaleType = Enum.ScaleType.Slice
    PenumbraShadow.SliceCenter = Rect.new(10, 10, 118, 118)

    ButtonHolder.Name = "ButtonHolder"
    ButtonHolder.Parent = ButtonHolderFrame
    ButtonHolder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ButtonHolder.BackgroundTransparency = 1.000
    ButtonHolder.Position = UDim2.new(0, 0, 0.0362903215, 0)
    ButtonHolder.Size = UDim2.new(0, 94, 0, 232)

    UIListLayout.Parent = ButtonHolder
    UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, 6)





    PenumbraShadow_2.Name = "PenumbraShadow"
    PenumbraShadow_2.Parent = MainFrame
    PenumbraShadow_2.AnchorPoint = Vector2.new(0.5, 0.5)
    PenumbraShadow_2.BackgroundTransparency = 1.000
    PenumbraShadow_2.BorderSizePixel = 0
    PenumbraShadow_2.Position = UDim2.new(0.5, 0, 0.5, 1)
    PenumbraShadow_2.Size = UDim2.new(1, 14, 1, 15)
    PenumbraShadow_2.ZIndex = -1
    PenumbraShadow_2.Image = "rbxassetid://1316045217"
    PenumbraShadow_2.ImageColor3 = Color3.fromRGB(0, 0, 0)
    PenumbraShadow_2.ImageTransparency = 0.600
    PenumbraShadow_2.ScaleType = Enum.ScaleType.Slice
    PenumbraShadow_2.SliceCenter = Rect.new(10, 10, 118, 118)

    allPages.Name = "allPages"
    allPages.Parent = MainFrame
    allPages.BackgroundColor3 = Color3.fromRGB(25,25,25)
    allPages.Position = UDim2.new(0.258823544, 0, 0.0474452563, 0)
    allPages.Size = UDim2.new(0, 307, 0, 248)

    UICorner_5.CornerRadius = UDim.new(0, 4)
    UICorner_5.Parent = allPages

    PenumbraShadow_3.Name = "PenumbraShadow"
    PenumbraShadow_3.Parent = allPages
    PenumbraShadow_3.AnchorPoint = Vector2.new(0.5, 0.5)
    PenumbraShadow_3.BackgroundTransparency = 1.000
    PenumbraShadow_3.BorderSizePixel = 0
    PenumbraShadow_3.Position = UDim2.new(0.5, 0, 0.5, 1)
    PenumbraShadow_3.Size = UDim2.new(1, 14, 1, 15)
    PenumbraShadow_3.ZIndex = -1
    PenumbraShadow_3.Image = "rbxassetid://1316045217"
    PenumbraShadow_3.ImageColor3 = Color3.fromRGB(0, 0, 0)
    PenumbraShadow_3.ImageTransparency = 0.800
    PenumbraShadow_3.ScaleType = Enum.ScaleType.Slice
    PenumbraShadow_3.SliceCenter = Rect.new(10, 10, 118, 118)





    Button.Name = "Button"
    Button.Parent = newPage
    Button.BackgroundColor3 = Color3.fromRGB(40,40,40)
    Button.Position = UDim2.new(0.0488599353, 0, 0, 0)
    Button.Size = UDim2.new(0, 277, 0, 37)
    Button.Font = Enum.Font.SourceSansBold
    Button.TextColor3 = Color3.fromRGB(253, 253, 253)
    Button.TextSize = 18.000

    UICorner_7.CornerRadius = UDim.new(0, 4)
    UICorner_7.Parent = Button

    PenumbraShadow_4.Name = "PenumbraShadow"
    PenumbraShadow_4.Parent = Button
    PenumbraShadow_4.AnchorPoint = Vector2.new(0.5, 0.5)
    PenumbraShadow_4.BackgroundTransparency = 1.000
    PenumbraShadow_4.BorderSizePixel = 0
    PenumbraShadow_4.Position = UDim2.new(0.5, 0, 0.5, 1)
    PenumbraShadow_4.Size = UDim2.new(1, 14, 1, 15)
    PenumbraShadow_4.ZIndex = -1
    PenumbraShadow_4.Image = "rbxassetid://1316045217"
    PenumbraShadow_4.ImageColor3 = Color3.fromRGB(0, 0, 0)
    PenumbraShadow_4.ImageTransparency = 0.800
    PenumbraShadow_4.ScaleType = Enum.ScaleType.Slice
    PenumbraShadow_4.SliceCenter = Rect.new(10, 10, 118, 118)

    local tabhandler = {}

    function tabhandler:CreateTab(name)
        name = name or ":D"
        local TabButton = Instance.new("TextButton")
        local ButtonShadow = Instance.new("ImageLabel")
        local UICorner_3 = Instance.new("UICorner")
        TabButton.Name = name
        TabButton.Parent = ButtonHolder
        TabButton.BackgroundColor3 = Color3.fromRGB(40,40,40)
        TabButton.Position = UDim2.new(0.122340426, 0, 0, 0)
        TabButton.Size = UDim2.new(0, 82, 0, 29)
        TabButton.AutoButtonColor = false
        TabButton.Text = name
        TabButton.Font = Enum.Font.SourceSansBold
        TabButton.TextColor3 = Color3.fromRGB(253, 253, 253)
        TabButton.TextSize = 14.000
        TabButton.AutoButtonColor = false
        ButtonShadow.Name = "ButtonShadow"
        ButtonShadow.Parent = TabButton
        ButtonShadow.AnchorPoint = Vector2.new(0.5, 0.5)
        ButtonShadow.BackgroundTransparency = 1.000
        ButtonShadow.BorderSizePixel = 0
        ButtonShadow.Position = UDim2.new(0.5, 0, 0.5, 1)
        ButtonShadow.Size = UDim2.new(1, 14, 1, 15)
        ButtonShadow.ZIndex = -1
        ButtonShadow.Image = "rbxassetid://1316045217"
        ButtonShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        ButtonShadow.ImageTransparency = 0.800
        ButtonShadow.ScaleType = Enum.ScaleType.Slice
        ButtonShadow.SliceCenter = Rect.new(10, 10, 118, 118)
        UICorner_3.CornerRadius = UDim.new(0, 2)
        UICorner_3.Parent = TabButton
        local newPage = Instance.new("ScrollingFrame")
        local UIListLayout_2 = Instance.new("UIListLayout")
        newPage.Name = "newPage"
        newPage.Parent = allPages
        newPage.Active = true
        newPage.Visible = false
        newPage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        newPage.BackgroundTransparency = 1.000
        newPage.BorderSizePixel = 0
        newPage.Position = UDim2.new(0, 0, 0.0362903215, 0)
        newPage.Size = UDim2.new(0, 307, 0, 239)
        newPage.CanvasSize = UDim2.new(0, 0, 10, 0)
        newPage.ScrollBarThickness = 4
        UIListLayout_2.Parent = newPage
        UIListLayout_2.Padding = UDim.new(0,5)
        UIListLayout_2.HorizontalAlignment = Enum.HorizontalAlignment.Center
        UIListLayout_2.SortOrder = Enum.SortOrder.LayoutOrder
        TabButton.MouseButton1Click:Connect(function()
            for i, v in pairs(allPages:GetChildren()) do
                if v:IsA("ScrollingFrame") then    
                    v.Visible = false 
                end
            end
            newPage.Visible = true
            for i, v in pairs(ButtonHolder:GetChildren()) do
                if v:IsA("TextButton") then
                    game:GetService("TweenService"):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
                        BackgroundColor3 = Color3.fromRGB(40,40,40)
                    }):Play();
                end
            end
            game:GetService("TweenService"):Create(TabButton, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
                BackgroundColor3 = Color3.fromRGB(50,50,50)
            }):Play();
        end)

        local elementhandler = {}

        function elementhandler:CreateButton(name,callback)
            callback = callback or function() end
            name = name or "Button"
            local Button = Instance.new("TextButton")
            local UICorner = Instance.new("UICorner")
            local PenumbraShadow = Instance.new("ImageLabel")
            local ms = game.Players.LocalPlayer:GetMouse()
            local btn = Button
            local Sample = Instance.new("ImageLabel")
            Sample.Name = "Sample"
            Sample.Parent = nil
            Sample.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            Sample.BackgroundTransparency = 1.000
            Sample.Image = "http://www.roblox.com/asset/?id=4560909609"
            Sample.ImageColor3 = Color3.fromRGB(100,100,100)
            Sample.ImageTransparency = 0.600
            local sample = Sample
            Button.Name = "Button"
            Button.AutoButtonColor = false
            Button.ClipsDescendants = true
            Button.Parent = newPage
            Button.BackgroundColor3 = Color3.fromRGB(40,40,40)
            Button.Position = UDim2.new(0.0488599353, 0, 0, 0)
            Button.Size = UDim2.new(0, 277, 0, 37)
            Button.Font = Enum.Font.SourceSansBold
            Button.TextColor3 = Color3.fromRGB(253, 253, 253)
            Button.TextSize = 18.000
            Button.Text = name
            Button.MouseButton1Click:Connect(function()
                spawn(function()
                    callback()
                    local c = sample:Clone()
                    c.Parent = btn
                    local x, y = (ms.X - c.AbsolutePosition.X), (ms.Y - c.AbsolutePosition.Y)
                    c.Position = UDim2.new(0, x, 0, y)
                    local len, size = 0.35, nil
                    if btn.AbsoluteSize.X >= btn.AbsoluteSize.Y then
                        size = (btn.AbsoluteSize.X * 1.5)
                    else
                        size = (btn.AbsoluteSize.Y * 1.5)
                    end
                    c:TweenSizeAndPosition(UDim2.new(0, size, 0, size), UDim2.new(0.5, (-size / 2), 0.5, (-size / 2)), 'Out', 'Quad', len, true, nil)
                    for i = 1, 10 do
                        c.ImageTransparency = c.ImageTransparency + 0.05
                        wait(len / 12)
                    end
                    c:Destroy()
                end)
            end)

            game.Players.LocalPlayer.Chatted:Connect(function(msg)
                a = string.gsub(name," ","")
                a = a:lower()
                if msg == _G.Prefix..a then
                    callback()
                end
            end)
            UICorner.CornerRadius = UDim.new(0, 4)
            UICorner.Parent = Button

            PenumbraShadow.Name = "PenumbraShadow"
            PenumbraShadow.Parent = Button
            PenumbraShadow.AnchorPoint = Vector2.new(0.5, 0.5)
            PenumbraShadow.BackgroundTransparency = 1.000
            PenumbraShadow.BorderSizePixel = 0
            PenumbraShadow.Position = UDim2.new(0.5, 0, 0.5, 1)
            PenumbraShadow.Size = UDim2.new(1, 14, 1, 15)
            PenumbraShadow.ZIndex = -1
            PenumbraShadow.Image = "rbxassetid://1316045217"
            PenumbraShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            PenumbraShadow.ImageTransparency = 0.800
            PenumbraShadow.ScaleType = Enum.ScaleType.Slice
            PenumbraShadow.SliceCenter = Rect.new(10, 10, 118, 118)
        end
        return elementhandler
    end
    return tabhandler
end

function playid(id) -- thanks to BXFE for this :D (all credits go to them)
   _G.PlayingAnim = true
   repeat wait() until game.Players.LocalPlayer.Character.Shiba
   animid="rbxassetid://"..tostring(id)
   plr=game.Players.LocalPlayer
   bruhmomentrighthahahahhahah=plr.Character.Shiba
   cf=bruhmomentrighthahahahhahah.HumanoidRootPart.CFrame
   t=bruhmomentrighthahahahhahah.Torso
   rs=t["Right Shoulder"]
   ls=t["Left Shoulder"]
   rh=t["Right Hip"]
   lh=t["Left Hip"]
   n=t["Neck"]
   rj=bruhmomentrighthahahahhahah.HumanoidRootPart["RootJoint"]
   rsc0=rs.C0
   lsc0=ls.C0
   rhc0=rh.C0
   lhc0=lh.C0
   rjc0=rj.C0
   nc0=n.C0
   gc0=CFrame.new()
   orsc0=rs.C0
   olsc0=ls.C0
   orhc0=rh.C0
   olhc0=lh.C0
   orjc0=rj.C0
   onc0=n.C0
   count2 = 100
   maxcount2=100
   game.Players.LocalPlayer.Character.Humanoid.Died:Connect(function()
       _G.PlayingAnim = false
   end)
   game["Run Service"].Heartbeat:Connect(function()
       count2 = count2+1
       if count2<=maxcount2 then
           rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
           ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
           rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
           lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
           n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
           rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
       end
   end)
   animid=game:GetObjects(animid)[1]
   function wait2(tim)
       if tim<0.1 then
           game.RunService.Heartbeat:Wait()
           game.RunService.Heartbeat:Wait()
       else
       for i=1,tim*40 do
           game.RunService.Heartbeat:Wait()
           game.RunService.Heartbeat:Wait()
       end
       end
   end
   anim={}
   function kftotbl(kf)
       tbl3 = {}
       for i,v in pairs(kf:GetDescendants()) do
           if v:IsA("Pose") then
           tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
           end
       end
       return(tbl3)
   end
   for i,v in pairs(animid:GetChildren()) do
       if v:IsA("Keyframe") then
       anim[v.Time]=kftotbl(v)
       end
   end

   function getnext(tbl,number)
   c=100
   rtrnv=0
   for i,v in pairs(tbl) do
       if i>number and i-number<c then
           c=i-number
           rtrnv=i
       end
   end
   return(rtrnv)
   end
   count = 0
   char=game.Players.LocalPlayer.Character.Shiba
   hhhh=game.Players.LocalPlayer.Character.Shiba.Humanoid.Animator
   hhhh.Parent = nil
   for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
       v:Stop()
   end
   while wait() do
   for i,oasjdadlasdkadkldjkl in pairs(anim) do
   asdf=getnext(anim,count)
   v=anim[asdf]
   if v["Lg"] then
       lhc0 = v["Lg"]
   end
   if v["Rg"] then
       rhc0 = v["Rg"]
   end
   if v["Lm"] then
       lsc0 = v["Lm"]
   end
   if v["Rm"] then
       rsc0 = v["Rm"]
   end
   if v["To"] then
       rjc0 = v["To"]
   end
   if v["Hd"] then
       nc0 = v["Hd"]
   end
   count2=0
   maxcount2=asdf-count
   count=asdf
   wait2(asdf-count)
   count2=maxcount2
   if v["Lg"] then
       char.Torso["Left Hip"].Transform = v["Lg"]
   end
   if v["Rg"] then
       char.Torso["Right Hip"].Transform = v["Rg"]
   end
   if v["Lm"] then
       char.Torso["Left Shoulder"].Transform = v["Lm"]
   end
   if v["Rm"] then
       char.Torso["Right Shoulder"].Transform = v["Rm"]
   end
   if v["To"] then
       char.HumanoidRootPart["RootJoint"].Transform = v["To"]
   end
   if v["Hd"] then
       char.Torso["Neck"].Transform = v["Hd"]
   end
   end
   end
end
function reanim()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Shiba/main/real"))('real')
end
function reanim2()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Shiba/main/real2"))('real')
end

local window = library:CreateMain()
local reanims = window:CreateTab("Reanimations")
local anims = window:CreateTab("Animations")
local b = window:CreateTab("Scripts")
local c = window:CreateTab("Hat Scripts")
local d = window:CreateTab("Misc")

reanims:CreateButton("R6 Normal Reanimation", function()
    reanim()
end)
reanims:CreateButton("R6 Fling Reanimation", function()
    reanim2()
end)

anims:CreateButton("Billy Bounce", function()
if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
playid("3381474830")
end)
anims:CreateButton("Orange Justice", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3262592866")
end)
anims:CreateButton("Rat", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("4746273203")
end)
anims:CreateButton("BrodyQuest", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3261753939")
end)
anims:CreateButton("Smug", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3450125501")
end)
anims:CreateButton("Blender", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3534855146")
end)
anims:CreateButton("Turk/Default Dance", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3259216638")
end)
anims:CreateButton("No Touchin'", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3414624197")
end)
anims:CreateButton("Crabby", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3643129020")
end)
anims:CreateButton("Boogie Down", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3623215692")
end)
anims:CreateButton("Casey", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("3442913250")
end)
anims:CreateButton("Carlton", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("4408536995")
end)
anims:CreateButton("Whip", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("4633952191")
end)
anims:CreateButton("Engineer", function()
   if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
   playid("4677980227")
end)
-- 10/2/2021 new added animations.
anims:CreateButton("Electro Shuffle", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("3619935462")
 end)
 anims:CreateButton("Soldier", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4787449997")
 end)
 anims:CreateButton("Floss", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4812941481")
 end)
 anims:CreateButton("Shuffle", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("3485013176")
 end)
 anims:CreateButton("Blowjob", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4963373273")
 end)
 anims:CreateButton("Bang", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4966879039")
 end)
 anims:CreateButton("Pushups", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4966881089")
 end)
 anims:CreateButton("Bend over", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4966882047")
 end)
 anims:CreateButton("Rewind", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("5011408603")
 end)
 anims:CreateButton("Aerostep", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4776588732")
 end)
 anims:CreateButton("Thriller", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4846220052")
 end)
 anims:CreateButton("Thriller 2.0", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4699820365")
 end)
 anims:CreateButton("Goopie", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("5238669868")
 end)
 anims:CreateButton("Skibidi", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("4835795413")
 end)
 anims:CreateButton("Carson Shearer", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    playid("5806573931")
 end)

b:CreateButton("Among Us",function()
    
    -- This script was converted using Shiba Animator v1.0 (Private & Created by garbag).
    -- Code might look scuffed because it is generated by AI.
    print("Shiba animator on top, created by garbag.")
    workspace.FallenPartsDestroyHeight = -math.huge
    local player = game.Players.LocalPlayer
    local char = player.Character.Shiba -- Change this to make it FE!
    local tor = char.Torso
    local rs = tor["Right Shoulder"]
    local ls = tor["Left Shoulder"]
    local rh = tor["Right Hip"]
    local lh = tor["Left Hip"]
    local rj = char.HumanoidRootPart["RootJoint"]
    local hum = char.Humanoid
    local cam = game.Workspace.CurrentCamera
    local uis = game:GetService("UserInputService")
    function swait(num)
        if num == 0 or num == nil then
            game:GetService("RunService").Stepped:wait()
        else
            for i = 0, num do
                game:GetService("RunService").Stepped:wait()
            end
        end
    end
    
    local venting = false
    uis.InputBegan:Connect(function(input,istyping)
        if not istyping then
            if input.KeyCode == Enum.KeyCode.V then
                venting = true
            end
        end
    end)
    uis.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.V then
                venting = false
            end
    end)
    local sine = 20
    cam.CameraSubject = char.Head
    game:GetService('RunService').Heartbeat:connect(function()
        sine = sine + 1
        for i, v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
    end)
    while true do
        swait()
        for i = 0, 1, 0.1 do
             swait()
    
        if game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude > 5 then
         rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1-0.05*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0+30*math.cos(sine/5)),math.rad(-15-5*math.cos(sine/20)),math.rad(0)),0.3)
         lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1-0.05*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0-30*math.cos(sine/5)),math.rad(15+5*math.cos(sine/20)),math.rad(0)),0.3)
    
        elseif game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude < 5 then
        rs.C0 = rs.C0:lerp(CFrame.new(.5, 0.5-0.1, .5)*CFrame.Angles(math.rad(0),math.rad(0-3*math.cos(sine/20)),math.rad(0)),0.3)
         ls.C0 = ls.C0:lerp(CFrame.new(-.5, 0.5-0.1, .5)*CFrame.Angles(math.rad(0),math.rad(0+3*math.cos(sine/20)),math.rad(0)),0.3)
         rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1-0.15*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0),math.rad(-15-5*math.cos(sine/20)),math.rad(0)),0.3)
         lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1-0.15*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0),math.rad(15+5*math.cos(sine/20)),math.rad(0)),0.3)
         rj.C0 = rj.C0:lerp(CFrame.new(0, 0+0.15*math.cos(sine/12), 0)*CFrame.Angles(math.rad(90),math.rad(180),math.rad(0)),0.3)
        end
    
        end
    end
    
end)
c:CreateButton("Among Us (With gun)",function()
    
    -- This script was converted using Shiba Animator v1.0 (Private & Created by garbag).
    -- Code might look scuffed because it is generated by AI.
    local function align(part0, part1)
        attachment = Instance.new("Attachment", part0)
        attachment.Position = Vector3.new(0,30,0) -- positioning
        attachment.Orientation = Vector3.new(0,0,0) -- orienation/rotation
    
        attachment02 = Instance.new("Attachment", part1) -- arm or part
    
        lol = Instance.new("AlignPosition", part0)
        lol.Attachment0 = attachment
        lol.Attachment1 = attachment02
        lol.MaxForce = 67734
        lol.RigidityEnabled = true -- makes it not wobbly
    
        pog = Instance.new("AlignOrientation", part0)
        pog.Attachment0 = attachment
        pog.Attachment1 = attachment02
        pog.Responsiveness = 200
        pog.RigidityEnabled = true-- makes it not wobbly
    end
    game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
    align(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, game.Players.LocalPlayer.Character.HumanoidRootPart)
    print("Shiba animator on top, created by garbag.")
    workspace.FallenPartsDestroyHeight = -math.huge
    local player = game.Players.LocalPlayer
    local char = player.Character.Shiba -- Change this to make it FE!
    local tor = char.Torso
    local rs = tor["Right Shoulder"]
    local ls = tor["Left Shoulder"]
    local rh = tor["Right Hip"]
    local lh = tor["Left Hip"]
    local rj = char.HumanoidRootPart["RootJoint"]
    local hum = char.Humanoid
    local cam = game.Workspace.CurrentCamera
    local uis = game:GetService("UserInputService")
    function swait(num)
        if num == 0 or num == nil then
            game:GetService("RunService").Stepped:wait()
        else
            for i = 0, num do
                game:GetService("RunService").Stepped:wait()
            end
        end
    end
    
    local venting = false
    uis.InputBegan:Connect(function(input,istyping)
        if not istyping then
            if input.KeyCode == Enum.KeyCode.V then
                venting = true
            end
        end
    end)
    uis.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.V then
                venting = false
            end
    end)
    local sine = 20
    cam.CameraSubject = char.Head
    game:GetService('RunService').Heartbeat:connect(function()
        sine = sine + 1
        for i, v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
            v:Stop()
        end
    end)
    while true do
        swait()
        for i = 0, 1, 0.1 do
             swait()
        if venting then
           -- gucci flip flops
            local hat = "VN9K [Front]"
            
            local attachment = game.Players.LocalPlayer.Character[hat].Handle.Attachment
            attachment.Orientation = Vector3.new(0, 90, 0)
            attachment.Position = Vector3.new(.3, .2, 1)
        else
                    local hat = "VN9K [Front]"
            
            local attachment = game.Players.LocalPlayer.Character[hat].Handle.Attachment
            attachment.Orientation = Vector3.new(0, 90, 0)
            attachment.Position = Vector3.new(.3, 15, 1)
        end
        if game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude > 5 then
         rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1-0.05*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0+30*math.cos(sine/5)),math.rad(-15-5*math.cos(sine/20)),math.rad(0)),0.3)
         lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1-0.05*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0-30*math.cos(sine/5)),math.rad(15+5*math.cos(sine/20)),math.rad(0)),0.3)
    
        elseif game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude < 5 then
        rs.C0 = rs.C0:lerp(CFrame.new(.5, 0.5-0.1, .5)*CFrame.Angles(math.rad(0),math.rad(0-3*math.cos(sine/20)),math.rad(0)),0.3)
         ls.C0 = ls.C0:lerp(CFrame.new(-.5, 0.5-0.1, .5)*CFrame.Angles(math.rad(0),math.rad(0+3*math.cos(sine/20)),math.rad(0)),0.3)
         rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1-0.15*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0),math.rad(-15-5*math.cos(sine/20)),math.rad(0)),0.3)
         lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1-0.15*math.cos(sine/12), 0.5)*CFrame.Angles(math.rad(0),math.rad(15+5*math.cos(sine/20)),math.rad(0)),0.3)
         rj.C0 = rj.C0:lerp(CFrame.new(0, 0+0.15*math.cos(sine/12), 0)*CFrame.Angles(math.rad(90),math.rad(180),math.rad(0)),0.3)
        end
    
        end
    end
    
end)
-- real
d:CreateButton("Fast Reset", function()
    local spawn = game.Players.RespawnTime + 0.2
    local pos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
    game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
    wait(spawn)
    repeat wait() until game.Players.LocalPlayer.Character
    repeat wait() until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = pos
end)
d:CreateButton("Normal Reset", function()
    local spawn = game.Players.RespawnTime + 0.2
    local pos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
    game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
    wait(spawn)
end)

b:CreateButton("Gale Fighter",function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
function LoadLibrary(a)
local t = {}
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------JSON Functions Begin----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
 
--JSON Encoder and Parser for Lua 5.1

--Permission is hereby granted, free of charge, to any person
--obtaining a copy of this software to deal in the Software without
--restriction, including without limitation the rights to use,
--copy, modify, merge, publish, distribute, sublicense, and/or
--sell copies of the Software, and to permit persons to whom the
--Software is furnished to do so, subject to the following conditions:
 
--The above copyright notice and this permission notice shall be
--included in all copies or substantial portions of the Software.
--If you find this software useful please give www.chipmunkav.com a mention.
 
--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
--EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
--OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
--IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
--ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
--CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
--CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
local string = string
local math = math
local table = table
local error = error
local tonumber = tonumber
local tostring = tostring
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local assert = assert
 
 
local StringBuilder = {
buffer = {}
}
 
function StringBuilder:New()
local o = {}
setmetatable(o, self)
self.__index = self
o.buffer = {}
return o
end
 
function StringBuilder:Append(s)
self.buffer[#self.buffer+1] = s
end
 
function StringBuilder:ToString()
return table.concat(self.buffer)
end
 
local JsonWriter = {
backslashes = {
['\b'] = "\\b",
['\t'] = "\\t",
['\n'] = "\\n",
['\f'] = "\\f",
['\r'] = "\\r",
['"'] = "\\\"",
['\\'] = "\\\\",
['/'] = "\\/"
}
}
 
function JsonWriter:New()
local o = {}
o.writer = StringBuilder:New()
setmetatable(o, self)
self.__index = self
return o
end
 
function JsonWriter:Append(s)
self.writer:Append(s)
end
 
function JsonWriter:ToString()
return self.writer:ToString()
end
 
function JsonWriter:Write(o)
local t = type(o)
if t == "nil" then
self:WriteNil()
elseif t == "boolean" then
self:WriteString(o)
elseif t == "number" then
self:WriteString(o)
elseif t == "string" then
self:ParseString(o)
elseif t == "table" then
self:WriteTable(o)
elseif t == "function" then
self:WriteFunction(o)
elseif t == "thread" then
self:WriteError(o)
elseif t == "userdata" then
self:WriteError(o)
end
end
 
function JsonWriter:WriteNil()
self:Append("null")
end
 
function JsonWriter:WriteString(o)
self:Append(tostring(o))
end
 
function JsonWriter:ParseString(s)
self:Append('"')
self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
local c = self.backslashes[n]
if c then return c end
return string.format("\\u%.4X", string.byte(n))
end))
self:Append('"')
end
 
function JsonWriter:IsArray(t)
local count = 0
local isindex = function(k)
if type(k) == "number" and k > 0 then
if math.floor(k) == k then
return true
end
end
return false
end
for k,v in pairs(t) do
if not isindex(k) then
return false, '{', '}'
else
count = math.max(count, k)
end
end
return true, '[', ']', count
end
 
function JsonWriter:WriteTable(t)
local ba, st, et, n = self:IsArray(t)
self:Append(st)
if ba then
for i = 1, n do
self:Write(t[i])
if i < n then
self:Append(',')
end
end
else
local first = true;
for k, v in pairs(t) do
if not first then
self:Append(',')
end
first = false;
self:ParseString(k)
self:Append(':')
self:Write(v)
end
end
self:Append(et)
end
 
function JsonWriter:WriteError(o)
error(string.format(
"Encoding of %s unsupported",
tostring(o)))
end
 
function JsonWriter:WriteFunction(o)
if o == Null then
self:WriteNil()
else
self:WriteError(o)
end
end
 
local StringReader = {
s = "",
i = 0
}
 
function StringReader:New(s)
local o = {}
setmetatable(o, self)
self.__index = self
o.s = s or o.s
return o
end
 
function StringReader:Peek()
local i = self.i + 1
if i <= #self.s then
return string.sub(self.s, i, i)
end
return nil
end
 
function StringReader:Next()
self.i = self.i+1
if self.i <= #self.s then
return string.sub(self.s, self.i, self.i)
end
return nil
end
 
function StringReader:All()
return self.s
end
 
local JsonReader = {
escapes = {
['t'] = '\t',
['n'] = '\n',
['f'] = '\f',
['r'] = '\r',
['b'] = '\b',
}
}
 
function JsonReader:New(s)
local o = {}
o.reader = StringReader:New(s)
setmetatable(o, self)
self.__index = self
return o;
end
 
function JsonReader:Read()
self:SkipWhiteSpace()
local peek = self:Peek()
if peek == nil then
error(string.format(
"Nil string: '%s'",
self:All()))
elseif peek == '{' then
return self:ReadObject()
elseif peek == '[' then
return self:ReadArray()
elseif peek == '"' then
return self:ReadString()
elseif string.find(peek, "[%+%-%d]") then
return self:ReadNumber()
elseif peek == 't' then
return self:ReadTrue()
elseif peek == 'f' then
return self:ReadFalse()
elseif peek == 'n' then
return self:ReadNull()
elseif peek == '/' then
self:ReadComment()
return self:Read()
else
return nil
end
end
 
function JsonReader:ReadTrue()
self:TestReservedWord{'t','r','u','e'}
return true
end
 
function JsonReader:ReadFalse()
self:TestReservedWord{'f','a','l','s','e'}
return false
end
 
function JsonReader:ReadNull()
self:TestReservedWord{'n','u','l','l'}
return nil
end
 
function JsonReader:TestReservedWord(t)
for i, v in ipairs(t) do
if self:Next() ~= v then
error(string.format(
"Error reading '%s': %s",
table.concat(t),
self:All()))
end
end
end
 
function JsonReader:ReadNumber()
local result = self:Next()
local peek = self:Peek()
while peek ~= nil and string.find(
peek,
"[%+%-%d%.eE]") do
result = result .. self:Next()
peek = self:Peek()
end
result = tonumber(result)
if result == nil then
error(string.format(
"Invalid number: '%s'",
result))
else
return result
end
end
 
function JsonReader:ReadString()
local result = ""
assert(self:Next() == '"')
while self:Peek() ~= '"' do
local ch = self:Next()
if ch == '\\' then
ch = self:Next()
if self.escapes[ch] then
ch = self.escapes[ch]
end
end
result = result .. ch
end
assert(self:Next() == '"')
local fromunicode = function(m)
return string.char(tonumber(m, 16))
end
return string.gsub(
result,
"u%x%x(%x%x)",
fromunicode)
end
 
function JsonReader:ReadComment()
assert(self:Next() == '/')
local second = self:Next()
if second == '/' then
self:ReadSingleLineComment()
elseif second == '*' then
self:ReadBlockComment()
else
error(string.format(
"Invalid comment: %s",
self:All()))
end
end
 
function JsonReader:ReadBlockComment()
local done = false
while not done do
local ch = self:Next()
if ch == '*' and self:Peek() == '/' then
done = true
end
if not done and
ch == '/' and
self:Peek() == "*" then
error(string.format(
"Invalid comment: %s, '/*' illegal.",
self:All()))
end
end
self:Next()
end
 
function JsonReader:ReadSingleLineComment()
local ch = self:Next()
while ch ~= '\r' and ch ~= '\n' do
ch = self:Next()
end
end
 
function JsonReader:ReadArray()
local result = {}
assert(self:Next() == '[')
local done = false
if self:Peek() == ']' then
done = true;
end
while not done do
local item = self:Read()
result[#result+1] = item
self:SkipWhiteSpace()
if self:Peek() == ']' then
done = true
end
if not done then
local ch = self:Next()
if ch ~= ',' then
error(string.format(
"Invalid array: '%s' due to: '%s'",
self:All(), ch))
end
end
end
assert(']' == self:Next())
return result
end
 
function JsonReader:ReadObject()
local result = {}
assert(self:Next() == '{')
local done = false
if self:Peek() == '}' then
done = true
end
while not done do
local key = self:Read()
if type(key) ~= "string" then
error(string.format(
"Invalid non-string object key: %s",
key))
end
self:SkipWhiteSpace()
local ch = self:Next()
if ch ~= ':' then
error(string.format(
"Invalid object: '%s' due to: '%s'",
self:All(),
ch))
end
self:SkipWhiteSpace()
local val = self:Read()
result[key] = val
self:SkipWhiteSpace()
if self:Peek() == '}' then
done = true
end
if not done then
ch = self:Next()
if ch ~= ',' then
error(string.format(
"Invalid array: '%s' near: '%s'",
self:All(),
ch))
end
end
end
assert(self:Next() == "}")
return result
end
 
function JsonReader:SkipWhiteSpace()
local p = self:Peek()
while p ~= nil and string.find(p, "[%s/]") do
if p == '/' then
self:ReadComment()
else
self:Next()
end
p = self:Peek()
end
end
 
function JsonReader:Peek()
return self.reader:Peek()
end
 
function JsonReader:Next()
return self.reader:Next()
end
 
function JsonReader:All()
return self.reader:All()
end
 
function Encode(o)
local writer = JsonWriter:New()
writer:Write(o)
return writer:ToString()
end
 
function Decode(s)
local reader = JsonReader:New(s)
return reader:Read()
end
 
function Null()
return Null
end
-------------------- End JSON Parser ------------------------
 
t.DecodeJSON = function(jsonString)
pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)
 
if type(jsonString) == "string" then
return Decode(jsonString)
end
print("RbxUtil.DecodeJSON expects string argument!")
return nil
end
 
t.EncodeJSON = function(jsonTable)
pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
return Encode(jsonTable)
end
 
 
 
 
 
 
 
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--makes a wedge at location x, y, z
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
--returns true if made a wedge, false if the cell remains a block
t.MakeWedge = function(x, y, z, defaultmaterial)
return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
end
 
t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
if not terrain then return end
 
assert(regionToSelect)
assert(color)
 
if not type(regionToSelect) == "Region3" then
error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
end
if not type(color) == "BrickColor" then
error("color (second arg), should be of type BrickColor, but is type",type(color))
end
 
-- frequently used terrain calls (speeds up call, no lookup necessary)
local GetCell = terrain.GetCell
local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
local CellCenterToWorld = terrain.CellCenterToWorld
local emptyMaterial = Enum.CellMaterial.Empty
 
-- container for all adornments, passed back to user
local selectionContainer = Instance.new("Model")
selectionContainer.Name = "SelectionContainer"
selectionContainer.Archivable = false
if selectionParent then
selectionContainer.Parent = selectionParent
else
selectionContainer.Parent = game:GetService("Workspace")
end
 
local updateSelection = nil -- function we return to allow user to update selection
local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
local aliveCounter = 0 -- helper for currentKeepAliveTag
local lastRegion = nil -- used to stop updates that do nothing
local adornments = {} -- contains all adornments
local reusableAdorns = {}
 
local selectionPart = Instance.new("Part")
selectionPart.Name = "SelectionPart"
selectionPart.Transparency = 1
selectionPart.Anchored = true
selectionPart.Locked = true
selectionPart.CanCollide = false
selectionPart.Size = Vector3.new(4.2,4.2,4.2)
 
local selectionBox = Instance.new("SelectionBox")
 
-- srs translation from region3 to region3int16
local function Region3ToRegion3int16(region3)
local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
local lowCell = WorldToCellPreferSolid(terrain,theLowVec)
 
local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
local highCell = WorldToCellPreferSolid(terrain, theHighVec)
 
local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)
 
return Region3int16.new(lowIntVec,highIntVec)
end
 
-- helper function that creates the basis for a selection box
function createAdornment(theColor)
local selectionPartClone = nil
local selectionBoxClone = nil
 
if #reusableAdorns > 0 then
selectionPartClone = reusableAdorns[1]["part"]
selectionBoxClone = reusableAdorns[1]["box"]
table.remove(reusableAdorns,1)
 
selectionBoxClone.Visible = true
else
selectionPartClone = selectionPart:Clone()
selectionPartClone.Archivable = false
 
selectionBoxClone = selectionBox:Clone()
selectionBoxClone.Archivable = false
 
selectionBoxClone.Adornee = selectionPartClone
selectionBoxClone.Parent = selectionContainer
 
selectionBoxClone.Adornee = selectionPartClone
 
selectionBoxClone.Parent = selectionContainer
end
 
if theColor then
selectionBoxClone.Color = theColor
end
 
return selectionPartClone, selectionBoxClone
end
 
-- iterates through all current adornments and deletes any that don't have latest tag
function cleanUpAdornments()
for cellPos, adornTable in pairs(adornments) do
 
if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
adornTable.SelectionBox.Visible = false
table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
adornments[cellPos] = nil
end
end
end
 
-- helper function to update tag
function incrementAliveCounter()
aliveCounter = aliveCounter + 1
if aliveCounter > 1000000 then
aliveCounter = 0
end
return aliveCounter
end
 
-- finds full cells in region and adorns each cell with a box, with the argument color
function adornFullCellsInRegion(region, color)
local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)
 
local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)
 
currentKeepAliveTag = incrementAliveCounter()
for y = cellPosBegin.y, cellPosEnd.y do
for z = cellPosBegin.z, cellPosEnd.z do
for x = cellPosBegin.x, cellPosEnd.x do
local cellMaterial = GetCell(terrain, x, y, z)
 
if cellMaterial ~= emptyMaterial then
local cframePos = CellCenterToWorld(terrain, x, y, z)
local cellPos = Vector3int16.new(x,y,z)
 
local updated = false
for cellPosAdorn, adornTable in pairs(adornments) do
if cellPosAdorn == cellPos then
adornTable.KeepAlive = currentKeepAliveTag
if color then
adornTable.SelectionBox.Color = color
end
updated = true
break
end
end
 
if not updated then
local selectionPart, selectionBox = createAdornment(color)
selectionPart.Size = Vector3.new(4,4,4)
selectionPart.CFrame = CFrame.new(cframePos)
local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
adornments[cellPos] = adornTable
end
end
end
end
end
cleanUpAdornments()
end
 
 
------------------------------------- setup code ------------------------------
lastRegion = regionToSelect
 
if selectEmptyCells then -- use one big selection to represent the area selected
local selectionPart, selectionBox = createAdornment(color)
 
selectionPart.Size = regionToSelect.Size
selectionPart.CFrame = regionToSelect.CFrame
 
adornments.SelectionPart = selectionPart
adornments.SelectionBox = selectionBox
 
updateSelection =
function (newRegion, color)
if newRegion and newRegion ~= lastRegion then
lastRegion = newRegion
selectionPart.Size = newRegion.Size
selectionPart.CFrame = newRegion.CFrame
end
if color then
selectionBox.Color = color
end
end
else -- use individual cell adorns to represent the area selected
adornFullCellsInRegion(regionToSelect, color)
updateSelection =
function (newRegion, color)
if newRegion and newRegion ~= lastRegion then
lastRegion = newRegion
adornFullCellsInRegion(newRegion, color)
end
end
 
end
 
local destroyFunc = function()
updateSelection = nil
if selectionContainer then selectionContainer:Destroy() end
adornments = nil
end
 
return updateSelection, destroyFunc
end
 
-----------------------------Terrain Utilities End-----------------------------
 
 
 
 
 
 
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Signal class begin------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
Arguments: The function to connect to.
Returns: A new connection object which can be used to disconnect the connection
Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
NOT mean that the first will be called before the second as a result of a call to |fire|.
 
Method :disconnect()
Arguments: None
Returns: None
Description: Disconnects all of the functions connected to this signal.
 
Method :fire( ... )
Arguments: Any arguments are accepted
Returns: None
Description: Calls all of the currently connected functions with the given arguments.
 
Method :wait()
Arguments: None
Returns: The arguments given to fire
Description: This call blocks until
]]
 
function t.CreateSignal()
local this = {}
 
local mBindableEvent = Instance.new('BindableEvent')
local mAllCns = {} --all connection objects returned by mBindableEvent::connect
 
--main functions
function this:connect(func)
if self ~= this then error("connect must be called with `:`, not `.`", 2) end
if type(func) ~= 'function' then
error("Argument #1 of connect must be a function, got a "..type(func), 2)
end
local cn = mBindableEvent.Event:Connect(func)
mAllCns[cn] = true
local pubCn = {}
function pubCn:disconnect()
cn:Disconnect()
mAllCns[cn] = nil
end
pubCn.Disconnect = pubCn.disconnect
 
return pubCn
end
 
function this:disconnect()
if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
for cn, _ in pairs(mAllCns) do
cn:Disconnect()
mAllCns[cn] = nil
end
end
 
function this:wait()
if self ~= this then error("wait must be called with `:`, not `.`", 2) end
return mBindableEvent.Event:Wait()
end
 
function this:fire(...)
if self ~= this then error("fire must be called with `:`, not `.`", 2) end
mBindableEvent:Fire(...)
end
 
this.Connect = this.connect
this.Disconnect = this.disconnect
this.Wait = this.wait
this.Fire = this.fire
 
return this
end
 
------------------------------------------------- Sigal class End ------------------------------------------------------
 
 
 
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------Create Function Begins---------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in
which case it simply creates an object of the given type, or a table argument that may contain several types of data,
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
|Create| call's body.
 
2) An integral key mapping to another Instance:
Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
need for temporary variables to store references to those objects.
 
3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy
for those who really want such a functionality. The name of the event whose name is passed to
Create.E( string )
 
4) A key which is the Create function itself, and a value which is a function
The function will be run with the argument of the object itself after all other initialization of the object is
done by create. This provides a way to do arbitrary things involving the object from withing the create
hierarchy.
Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the
constructor callback function is possible, it is probably not a good design choice.
Note: Since the constructor function is called after all other initialization, a Create block cannot have two
constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
 
 
Some example usages:
 
A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
Name = 'A New model',
Parent = game.Workspace,
}
 
 
An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
|-ObjectValue
| |
| `-BoolValueChild
`-IntValue
 
local model = Create'Model'{
Name = 'Model_Container',
Create'ObjectValue'{
Create'BoolValue'{
Name = 'BoolValueChild',
},
},
Create'IntValue'{},
}
 
 
An example using the event syntax:
 
local part = Create'Part'{
[Create.E'Touched'] = function(part)
print("I was touched by "..part.Name)
end,
}
 
 
An example using the general constructor syntax:
 
local model = Create'Part'{
[Create] = function(this)
print("Constructor running!")
this.Name = GetGlobalFoosAndBars(this)
end,
}
 
 
Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
any unexpected behavior. EG:
local partCreatingFunction = Create'Part'
local part = partCreatingFunction()
]]
 
--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
--will be created in several steps rather than as a single function declaration.
local function Create_PrivImpl(objectType)
if type(objectType) ~= 'string' then
error("Argument of Create must be a string", 2)
end
--return the proxy function that gives us the nice Create'string'{data} syntax
--The first function call is a function call using Lua's single-string-argument syntax
--The second function call is using Lua's single-table-argument syntax
--Both can be chained together for the nice effect.
return function(dat)
--default to nothing, to handle the no argument given case
dat = dat or {}
 
--make the object to mutate
local obj = Instance.new(objectType)
local parent = nil
 
--stored constructor function to be called after other initialization
local ctor = nil
 
for k, v in pairs(dat) do
--add property
if type(k) == 'string' then
if k == 'Parent' then
-- Parent should always be set last, setting the Parent of a new object
-- immediately makes performance worse for all subsequent property updates.
parent = v
else
obj[k] = v
end
 
 
--add child
elseif type(k) == 'number' then
if type(v) ~= 'userdata' then
error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
end
v.Parent = obj
 
 
--event connect
elseif type(k) == 'table' and k.__eventname then
if type(v) ~= 'function' then
error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
got: "..tostring(v), 2)
end
obj[k.__eventname]:connect(v)
 
 
--define constructor function
elseif k == t.Create then
if type(v) ~= 'function' then
error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: "..tostring(v), 2)
elseif ctor then
--ctor already exists, only one allowed
error("Bad entry in Create body: Only one constructor function is allowed", 2)
end
ctor = v
 
 
else
error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
end
end
 
--apply constructor function if it exists
if ctor then
ctor(obj)
end
 
if parent then
obj.Parent = parent
end
 
--return the completed object
return obj
end
end
 
--now, create the functor:
t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
 
--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
t.Create.E = function(eventName)
return {__eventname = eventName}
end
 
-------------------------------------------------Create function End----------------------------------------------------
 
 
 
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Documentation Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
 
t.Help =
function(funcNameOrFunc)
--input argument can be a string or a function. Should return a description (of arguments and expected side effects)
if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
return "Function DecodeJSON. " ..
"Arguments: (string). " ..
"Side effect: returns a table with all parsed JSON values"
end
if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
return "Function EncodeJSON. " ..
"Arguments: (table). " ..
"Side effect: returns a string composed of argument table in JSON data format"
end
if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
return "Function MakeWedge. " ..
"Arguments: (x, y, z, [default material]). " ..
"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
"Returns true if made a wedge, false if the cell remains a block "
end
if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
return "Function SelectTerrainRegion. " ..
"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
"(this should be a region3 value). The selection box color is detemined by the color argument " ..
"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
"SelectEmptyCells is bool, when true will select all cells in the " ..
"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
"Also returns a second function that takes no arguments and destroys the selection"
end
if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
return "Function CreateSignal. "..
"Arguments: None. "..
"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
"Lua code. "..
"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
"For more info you can pass the method name to the Help function, or view the wiki page "..
"for this library. EG: Help('Signal:connect')."
end
if funcNameOrFunc == "Signal:connect" then
return "Method Signal:connect. "..
"Arguments: (function handler). "..
"Return: A connection object which can be used to disconnect the connection to this handler. "..
"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
"handler function will be called with the arguments passed to |fire|."
end
if funcNameOrFunc == "Signal:wait" then
return "Method Signal:wait. "..
"Arguments: None. "..
"Returns: The arguments passed to the next call to |fire|. "..
"Description: This call does not return until the next call to |fire| is made, at which point it "..
"will return the values which were passed as arguments to that |fire| call."
end
if funcNameOrFunc == "Signal:fire" then
return "Method Signal:fire. "..
"Arguments: Any number of arguments of any type. "..
"Returns: None. "..
"Description: This call will invoke any connected handler functions, and notify any waiting code "..
"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
"it takes the connected handler functions to complete."
end
if funcNameOrFunc == "Signal:disconnect" then
return "Method Signal:disconnect. "..
"Arguments: None. "..
"Returns: None. "..
"Description: This call disconnects all handlers attacched to this function, note however, it "..
"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
"can also be called on the connection object which is returned from Signal:connect to only "..
"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
end
if funcNameOrFunc == "Create" then
return "Function Create. "..
"Arguments: A table containing information about how to construct a collection of objects. "..
"Returns: The constructed objects. "..
"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
"is best described via example, please see the wiki page for a description of how to use it."
end
end
 
--------------------------------------------Documentation Ends----------------------------------------------------------
 
return t
end
 
--[[ Name : Gale Fighter ]]--
-------------------------------------------------------
--A Collaboration Between makhail07 and KillerDarkness0105
 
--Base Animaion by makhail07, attacks by KillerDarkness0105
-------------------------------------------------------
 
 
local FavIDs = {
340106355, --Nefl Crystals
927529620, --Dimension
876981900, --Fantasy
398987889, --Ordinary Days
1117396305, --Oh wait, it's you.
885996042, --Action Winter Journey
919231299, --Sprawling Idiot Effigy
743466274, --Good Day Sunshine
727411183, --Knife Fight
1402748531, --The Earth Is Counting On You!
595230126 --Robot Language
}
 
 
 
--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:GetService("Players").LocalPlayer
print('Local User is '..plr.Name)
print('Gale Fighter Loaded')
print('The Fighter that is as fast as wind, a true Fighter')
local char = plr.Character.Shiba
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
hum.MaxHealth = 200
hum.Health = 200
 

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil
RW = Instance.new("Weld")
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"]
LSH = tors["Left Shoulder"]
RSH.Parent = nil
LSH.Parent = nil
RW.Name = "RW"
RW.Part0 = tors
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0)
RW.Part1 = ra
RW.Parent = tors
LW.Name = "LW"
LW.Part0 = tors
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0)
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
 
frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false
 
 
lastframe = tick()
script.Heartbeat:Fire()
 
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------
 
 
 
-------------------------------------------------------
--Start Combo Function--
-------------------------------------------------------
local comboing = false
local combohits = 0
local combotime = 0
local maxtime = 65
 
 
 
function sandbox(var,func)
local env = getfenv(func)
local newenv = setmetatable({},{
__index = function(self,k)
if k=="script" then
return var
else
return env[k]
end
end,
})
setfenv(func,newenv)
return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
comboframe = Instance.new("ScreenGui")
Frame1 = Instance.new("Frame")
Frame2 = Instance.new("Frame")
TextLabel3 = Instance.new("TextLabel")
comboframe.Name = "combinserter"
comboframe.Parent = mas
Frame1.Name = "combtimegui"
Frame1.Parent = comboframe
Frame1.Size = UDim2.new(0, 300, 0, 14)
Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
Frame1.BorderSizePixel = 5
Frame2.Name = "combtimeoverlay"
Frame2.Parent = Frame1
Frame2.Size = UDim2.new(0, 0, 0, 14)
Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
Frame2.ZIndex = 2
TextLabel3.Parent = Frame2
TextLabel3.Transparency = 0
TextLabel3.Size = UDim2.new(0, 300, 0, 50)
TextLabel3.Text ="Hits: "..combohits
TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel3.BackgroundTransparency = 1
TextLabel3.Font = Enum.Font.Bodoni
TextLabel3.FontSize = Enum.FontSize.Size60
TextLabel3.TextColor3 = Color3.new(0, 1, 0)
TextLabel3.TextStrokeTransparency = 0
gui = game:GetService("Players").LocalPlayer.PlayerGui
for i,v in pairs(mas:GetChildren()) do
v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
spawn(function()
pcall(v)
end)
end
 
 
 
 
 
coroutine.resume(coroutine.create(function()
while true do
wait()
 
 
if combotime>65 then
combotime = 65
end
 
 
 
 
 
if combotime>.1 and comboing == true then
TextLabel3.Transparency = 0
TextLabel3.TextStrokeTransparency = 0
TextLabel3.BackgroundTransparency = 1
Frame1.Transparency = 0
Frame2.Transparency = 0
TextLabel3.Text ="Hits: "..combohits
combotime = combotime - .34
Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
end
 
 
 
 
if combotime<.1 then
TextLabel3.BackgroundTransparency = 1
TextLabel3.Transparency = 1
TextLabel3.TextStrokeTransparency = 1
 
Frame2.Size = UDim2.new(0, 0, 0, 14)
combotime = 0
comboing = false
Frame1.Transparency = 1
Frame2.Transparency = 1
combohits = 0
 
end
end
end))
 
 
 
-------------------------------------------------------
--End Combo Function--
-------------------------------------------------------
 
-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
if num == 0 or num == nil then
game:service("RunService").Stepped:wait(0)
else
for i = 0, num do
game:service("RunService").Stepped:wait(0)
end
end
end
function thread(f)
coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
local qa = {
QuaternionFromCFrame(a)
}
local qb = {
QuaternionFromCFrame(b)
}
local ax, ay, az = a.x, a.y, a.z
local bx, by, bz = b.x, b.y, b.z
local _t = 1 - t
return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
local trace = m00 + m11 + m22
if trace > 0 then
local s = math.sqrt(1 + trace)
local recip = 0.5 / s
return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
else
local i = 0
if m00 < m11 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then
i = 2
end
if i == 0 then
local s = math.sqrt(m00 - m11 - m22 + 1)
local recip = 0.5 / s
return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
elseif i == 1 then
local s = math.sqrt(m11 - m22 - m00 + 1)
local recip = 0.5 / s
return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
elseif i == 2 then
local s = math.sqrt(m22 - m00 - m11 + 1)
local recip = 0.5 / s
return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
end
end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
local xs, ys, zs = x + x, y + y, z + z
local wx, wy, wz = w * xs, w * ys, w * zs
local xx = x * xs
local xy = x * ys
local xz = x * zs
local yy = y * ys
local yz = y * zs
local zz = z * zs
return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
local startInterp, finishInterp
if cosTheta >= 1.0E-4 then
if 1 - cosTheta > 1.0E-4 then
local theta = math.acos(cosTheta)
local invSinTheta = 1 / Sin(theta)
startInterp = Sin((1 - t) * theta) * invSinTheta
finishInterp = Sin(t * theta) * invSinTheta
else
startInterp = 1 - t
finishInterp = t
end
elseif 1 + cosTheta > 1.0E-4 then
local theta = math.acos(-cosTheta)
local invSinTheta = 1 / Sin(theta)
startInterp = Sin((t - 1) * theta) * invSinTheta
finishInterp = Sin(t * theta) * invSinTheta
else
startInterp = t - 1
finishInterp = t
end
return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
 
-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
 
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------
 
-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
local Rate = (1 / 30)
local Pos = (Pos or Vector3.new(0, 0, 0))
local Text = (Text or "")
local Time = (Time or 2)
local Color = (Color or Color3.new(1, 0, 1))
local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
EffectPart.Anchored = true
local BillboardGui = Create("BillboardGui"){
Size = UDim2.new(3, 0, 3, 0),
Adornee = EffectPart,
Parent = EffectPart,
}
local TextLabel = Create("TextLabel"){
BackgroundTransparency = 1,
Size = UDim2.new(1, 0, 1, 0),
Text = Text,
Font = "Bodoni",
TextColor3 = Color,
TextScaled = true,
TextStrokeColor3 = Color3.fromRGB(0,0,0),
Parent = BillboardGui,
}
game.Debris:AddItem(EffectPart, (Time))
EffectPart.Parent = game:GetService("Workspace")
delay(0, function()
local Frames = (Time / Rate)
for Frame = 1, Frames do
wait(Rate)
local Percent = (Frame / Frames)
EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
TextLabel.TextTransparency = Percent
end
if EffectPart and EffectPart.Parent then
EffectPart:Destroy()
end
end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------
 
CFuncs = {
Part = {
Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part")({
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material
})
RemoveOutlines(Part)
return Part
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Weld = {
Create = function(Parent, Part0, Part1, C0, C1)
local Weld = Create("Weld")({
Parent = Parent,
Part0 = Part0,
Part1 = Part1,
C0 = C0,
C1 = C1
})
return Weld
end
},
Sound = {
Create = function(id, par, vol, pit)
coroutine.resume(coroutine.create(function()
local S = Create("Sound")({
Volume = vol,
Pitch = pit or 1,
SoundId = id,
Parent = par or workspace
})
wait()
S:play()
game:GetService("Debris"):AddItem(S, 6)
end))
end
},
ParticleEmitter = {
Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
local fp = Create("ParticleEmitter")({
Parent = Parent,
Color = ColorSequence.new(Color1, Color2),
LightEmission = LightEmission,
Size = Size,
Texture = Texture,
Transparency = Transparency,
ZOffset = ZOffset,
Acceleration = Accel,
Drag = Drag,
LockedToPart = LockedToPart,
VelocityInheritance = VelocityInheritance,
EmissionDirection = EmissionDirection,
Enabled = Enabled,
Lifetime = LifeTime,
Rate = Rate,
Rotation = Rotation,
RotSpeed = RotSpeed,
Speed = Speed,
VelocitySpread = VelocitySpread
})
return fp
end
}
}
function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part")({
formFactor = FormFactor,
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material
})
RemoveOutlines(Part)
return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
local Weld = Create("Weld")({
Parent = Parent,
Part0 = Part0,
Part1 = Part1,
C0 = C0,
C1 = C1
})
return Weld
end
 
 
-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
Block = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
if Type == 1 or Type == nil then
table.insert(Effects, {
prt,
"Block1",
delay,
x3,
y3,
z3,
msh
})
elseif Type == 2 then
table.insert(Effects, {
prt,
"Block2",
delay,
x3,
y3,
z3,
msh
})
else
table.insert(Effects, {
prt,
"Block3",
delay,
x3,
y3,
z3,
msh
})
end
end
},
Sphere = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
},
Cylinder = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
},
Wave = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3 / 60,
y3 / 60,
z3 / 60,
msh
})
end
},
Ring = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
},
Break = {
Create = function(brickcolor, cframe, x1, y1, z1)
local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
prt.Anchored = true
prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
local num = math.random(10, 50) / 1000
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Shatter",
num,
prt.CFrame,
math.random() - math.random(),
0,
math.random(50, 100) / 100
})
end
},
Spiral = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
},
Push = {
Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
}
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
local fp = IT("Part")
fp.formFactor = formfactor
fp.Parent = parent
fp.Reflectance = reflectance
fp.Transparency = transparency
fp.CanCollide = false
fp.Locked = true
fp.BrickColor = brickcolor
fp.Name = name
fp.Size = size
fp.Position = tors.Position
RemoveOutlines(fp)
fp.Material = "SmoothPlastic"
fp:BreakJoints()
return fp
end
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh = IT(Mesh)
mesh.Parent = part
if Mesh == "SpecialMesh" then
mesh.MeshType = meshtype
if meshid ~= "nil" then
mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset = offset
mesh.Scale = scale
return mesh
end
 
function Magic(bonuspeed, type, pos, scale, value, color, MType)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = MType
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1 * value
elseif type == "Divide" then
scaler2 = 1 / value
end
coroutine.resume(coroutine.create(function()
for i = 0, 10 / bonuspeed, 0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01 * value / bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01 / value * bonuspeed
end
rng.Transparency = rng.Transparency + 0.01 * bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
end
rng:Destroy()
end))
end
 
function Eviscerate(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
target = nil
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local PartEmmit1 = IT("ParticleEmitter", v)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://284205403"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 150
PartEmmit1.Lifetime = NumberRange.new(1)
PartEmmit1.Size = NumberSequence.new({
NumberSequenceKeypoint.new(0, 0.75, 0),
NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
NumberSequenceKeypoint.new(0, 0, 0),
NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-500, 500)
PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
local BodPoss = IT("BodyPosition", v)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
v.Color = maincolor.Color
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.08
end
wait(0.5)
PartEmmit1.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end
end
 
function FindNearestHead(Position, Distance, SinglePlayer)
if SinglePlayer then
return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
end
local List = {}
for i, v in pairs(workspace:GetChildren()) do
if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
table.insert(List, v)
end
end
return List
end
 
function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = MType
rngm.Scale = Vector3.new(x1, y1, z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1 * value
elseif type == "Divide" then
scaler2 = 1 / value
end
coroutine.resume(coroutine.create(function()
for i = 0, 10 / bonuspeed, 0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01 * value / bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01 / value * bonuspeed
end
speeder = speeder - 0.01 * FastSpeed * bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
rng.Transparency = rng.Transparency + 0.01 * bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
end
rng:Destroy()
end))
end
 
function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
NumberSequenceKeypoint.new(0, 1, 0),
NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
NumberSequenceKeypoint.new(0, 0, 0),
NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
if hit.Parent == char then
soul:Destroy()
end
end)
wait(1.2)
while soul do
swait()
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
BodPoss.Position = tors.Position
end
end)
soulst()
end
end
 
 
 
 
--killer's effects
 
 
 
 
 
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part"){
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material,
}
RemoveOutlines(Part)
return Part
end
 
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh){
Parent = Part,
Offset = OffSet,
Scale = Scale,
}
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
 
 
 
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
if Type == 1 or Type == nil then
table.insert(Effects, {
prt,
"Block1",
delay,
x3,
y3,
z3,
msh
})
elseif Type == 2 then
table.insert(Effects, {
prt,
"Block2",
delay,
x3,
y3,
z3,
msh
})
end
end
 
function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num)
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end
 
function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
 
function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
prt.Anchored = true
prt.CFrame = cframe
local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Cylinder",
delay,
x3,
y3,
z3,
msh
})
end
 
function BreakEffect(brickcolor, cframe, x1, y1, z1)
local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
prt.Anchored = true
prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
local num = math.random(10, 50) / 1000
game:GetService("Debris"):AddItem(prt, 10)
table.insert(Effects, {
prt,
"Shatter",
num,
prt.CFrame,
math.random() - math.random(),
0,
math.random(50, 100) / 100
})
end
 
 
 
 
 
so = function(id,par,vol,pit)
coroutine.resume(coroutine.create(function()
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId=id
sou:play()
game:GetService("Debris"):AddItem(sou,8)
end))
end
 
 
--end of killer's effects
 
 
function FaceMouse()
local Cam = workspace.CurrentCamera
return {
CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
local NSound = nil
coroutine.resume(coroutine.create(function()
NSound = IT("Sound", PARENT)
NSound.Volume = VOLUME
NSound.Pitch = PITCH
NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
swait()
NSound:play()
game:GetService("Debris"):AddItem(NSound, 10)
end))
return NSound
end
function CameraEnshaking(Length, Intensity)
coroutine.resume(coroutine.create(function()
local intensity = 1 * Intensity
local rotM = 0.01 * Intensity
for i = 0, Length, 0.1 do
swait()
intensity = intensity - 0.05 * Intensity / Length
rotM = rotM - 5.0E-4 * Intensity / Length
hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
end
hum.CameraOffset = Vector3.new(0, 0, 0)
end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 900817147 --900817147
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 0.7
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ
local cankick = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
ANIMATOR.Parent = nil
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
 
--pls be proud mak i did my best
 
 
 
function attackone()
 
attack = true
 
for i = 0, 1.35, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
 
so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))
 
 
con5=ra.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
 
so("http://roblox.com/asset/?id=636494529",ra,2,1)
 
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
 
 
wait(0.34)
attackdebounce = false
 
end
end
end)
for i = 0, 1.12, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
end
 
con5:Disconnect()
attack = false
 
end
 
 
 
 
 
 
 
 
 
 
 
 
function attacktwo()
 
attack = true
 
for i = 0, 1.35, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
 
so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))
 
 
con5=la.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
 
so("http://roblox.com/asset/?id=636494529",la,2,1)
 
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
 
 
wait(0.34)
attackdebounce = false
 
end
end
end)
 
 
 
 
for i = 0, 1.12, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
end
 
con5:Disconnect()
attack = false
 
end
 
 
 
 
 
function attackthree()
 
attack = true
 
 
for i = 0, 1.14, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
end
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
 
so("http://roblox.com/asset/?id=636494529",ll,2,1)
 
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
 
 
wait(0.34)
attackdebounce = false
 
end
end
end)
 
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
for i = 0, 9.14, 0.3 do
swait()
BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
end
attack = false
con5:disconnect()
end
 
 
 
function attackfour()
 
attack = true
so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
for i = 0, 5.14, 0.1 do
swait()
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
end
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
local velo=Instance.new("BodyVelocity")
velo.velocity=vt(0,25,0)
velo.P=8000
velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
velo.Parent=root
game:GetService("Debris"):AddItem(velo,0.7)
 
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
end
end))
 
 
wait(0.14)
attackdebounce = false
end
end
end)
 
for i = 0, 5.11, 0.15 do
swait()
BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
end
 
 
attack = false
con5:disconnect()
end
 
 
 
 
 
local cooldown = false
function quickkick()
attack = true
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
 
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
end
end))
 
so("http://roblox.com/asset/?id=636494529",rl,2,1)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
end
end))
 
 
wait(0.08)
attackdebounce = false
end
end
end)
 
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
for i = 0, 11.14, 0.3 do
swait()
root.Velocity = root.CFrame.lookVector * 30
BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
end
attack = false
con5:disconnect()
end
 
 
 
 
 
 
 
 
function Taunt()
attack = true
hum.WalkSpeed = 0
Cso("1535995570", hed, 8.45, 1)
for i = 0, 8.2, 0.1 do
swait()
hum.WalkSpeed = 0
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
end
attack = false
hum.WalkSpeed = 8
end
 
 
 
 
 
 
 
function Hyperkickcombo()
 
attack = true
so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
for i = 0, 7.14, 0.1 do
swait()
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
end
local Cracking = Cso("292536356", tors, 10, 1)
for i = 0, 7.14, 0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
end
Cracking.Playing = false
so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
local velo=Instance.new("BodyVelocity")
velo.velocity=vt(0,27,0)
velo.P=11000
velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
velo.Parent=root
game:GetService("Debris"):AddItem(velo,1.24)
 
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.09)
attackdebounce = false
end
end
end)
 
for i = 0, 9.11, 0.2 do
swait()
BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
end
 
 
 
 
con5:disconnect()
 
 
 
 
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.08)
attackdebounce = false
end
end
end)
 
 
 
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
for i = 0, 9.14, 0.3 do
swait()
root.Velocity = root.CFrame.lookVector * 20
BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
end
 
 
 
con5:disconnect()
 
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.05)
attackdebounce = false
end
end
end)
 
 
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
for i = 0, 15.14, 0.32 do
swait()
root.Velocity = root.CFrame.lookVector * 20
BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
end
 
attack = false
con5:disconnect()
 
end
 
 
 
 
 
local ultra = false
 
function Galekicks()
 
attack = true
so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
for i = 0, 1.65, 0.1 do
swait()
root.Velocity = root.CFrame.lookVector * 0
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
 
 
for i = 1, 17 do
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.05)
attackdebounce = false
end
end
end)
 
for i = 0, .1, 0.2 do
swait()
BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
root.Velocity = root.CFrame.lookVector * 10
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
end
 
so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
 
for i = 0, 0.4, 0.2 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
con5:disconnect()
end
 
 
u = mouse.KeyDown:connect(function(key)
if key == 'r' and combohits >= 150 then
ultra = true
SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
end
end)
wait(0.3)
if ultra == true then
combohits = 0
wait(0.1)
for i = 0, 1.65, 0.1 do
swait()
root.Velocity = root.CFrame.lookVector * 0
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
 
 
so("http://roblox.com/asset/?id=146094803",hed,1,1.2)
 
for i = 1, 65 do
--Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.05)
attackdebounce = false
end
end
end)
 
for i = 0, .03, 0.1 do
swait()
BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
root.Velocity = root.CFrame.lookVector * 10
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
end
 
so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
 
for i = 0, 0.07, 0.1 do
swait()
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
con5:disconnect()
end
 
for i = 0, 1.65, 0.1 do
swait()
root.Velocity = root.CFrame.lookVector * 0
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
coroutine.resume(coroutine.create(function()
for i = 0,1.5,0.1 do
swait()
--hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
so("http://roblox.com/asset/?id=636494529",rl,2,.63)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
 
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))
 
 
wait(0.05)
attackdebounce = false
end
end
end)
 
so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
 
for i = 0, 2, 0.1 do
swait()
--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
end
SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
 
wait(0.25)
con5:Disconnect()
 
 
 
 
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true
 
so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
 
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)
 
coroutine.resume(coroutine.create(function()
for i = 0,1,0.1 do
swait()
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
 
wait(0.06)
attackdebounce = false
 
end
end
end)
 
coroutine.resume(coroutine.create(function()
while ultra == true do
swait()
root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
end
end))
 
 
so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
for i = 1,3 do
for i = 0, 9.14, 0.45 do
swait()
root.Velocity = root.CFrame.lookVector * 30
BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
end
end
 
 
for i = 1,3 do
for i = 0, 11.14, 0.45 do
swait()
root.Velocity = root.CFrame.lookVector * 30
BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
end
 
 
 
end
so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
con5:disconnect()
 
 
end -- combo hit end
attack = false
ultra = false
u:disconnect()
 
end
 
 
 
 
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
if string.byte(key) == 48 then
Swing = 2
hum.WalkSpeed = 24.82
end
end)
mouse.KeyUp:connect(function(key)
if string.byte(key) == 48 then
Swing = 1
hum.WalkSpeed = 8
end
end)
 
 
 
 
 
 
 
mouse.Button1Down:connect(function()
if attack==false then
if attacktype==1 then
attack=true
attacktype=2
attackone()
elseif attacktype==2 then
attack=true
attacktype=3
attacktwo()
elseif attacktype==3 then
attack=true
attacktype=4
attackthree()
elseif attacktype==4 then
attack=true
attacktype=1
attackfour()
end
end
end)
 
 
 
 
mouse.KeyDown:connect(function(key)
if key == 'e' and attack == false and cankick == true and cooldown == false then
quickkick()
cooldown = true
 
coroutine.resume(coroutine.create(function()
wait(2)
cooldown = false
end))
 
 
 
end
end)
 
 
 
 
 
 
 
 
mouse.KeyDown:connect(function(key)
if attack == false then
if key == 't' then
Taunt()
elseif key == 'f' then
Hyperkickcombo()
elseif key == 'r' then
Galekicks()
end
end
end)
 
-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07 and KillerDarkness0105")
print("Basic Animations by Makhail07")
print("Attack Animations by KillerDarkness0105")
print("This is pretty much our final script together")
print("--------------------------------")
print("Attacks")
print("E in air: Quick Kicks")
print("Left Mouse: 4 click combo")
print("F: Hyper Kicks")
print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
print("--------------------------------")
while true do
swait()
sine = sine + change
local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
local velderp = root.Velocity.y
hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
 
if hitfloor == nil then
cankick = true
else
cankick = false
end
 
 
if equipped == true or equipped == false then
if attack == false then
idle = idle + 1
else
idle = 0
end
if 1 < root.Velocity.y and hitfloor == nil then
Anim = "Jump"
if attack == false then
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
end
elseif -1 > root.Velocity.y and hitfloor == nil then
Anim = "Fall"
if attack == false then
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
end
elseif torvel < 1 and hitfloor ~= nil then
Anim = "Idle"
change = 1
if attack == false then
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
end
elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
Anim = "Walk"
change = 1
if attack == false then
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 75), 0.1)
end
elseif torvel >= 22 and hitfloor ~= nil then
Anim = "Sprint"
change = 1.35
if attack == false then
hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0) , Rad(-13) + la.RotVelocity.Y / 75), 0.15)
end
end
end
Music.SoundId = "rbxassetid://"..SONG
Music.Looped = true
Music.Pitch = 1
Music.Volume = 0.7
Music.Parent = tors
Music:Resume()
if 0 < #Effects then
for e = 1, #Effects do
if Effects[e] ~= nil then
local Thing = Effects[e]
if Thing ~= nil then
local Part = Thing[1]
local Mode = Thing[2]
local Delay = Thing[3]
local IncX = Thing[4]
local IncY = Thing[5]
local IncZ = Thing[6]
if 1 >= Thing[1].Transparency then
if Thing[2] == "Block1" then
Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
local Mesh = Thing[1].Mesh
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Block2" then
Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
local Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Block3" then
Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
local Mesh = Thing[7]
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Cylinder" then
local Mesh = Thing[1].Mesh
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Blood" then
local Mesh = Thing[7]
Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Elec" then
local Mesh = Thing[1].Mesh
Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Disappear" then
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
elseif Thing[2] == "Shatter" then
Thing[1].Transparency = Thing[1].Transparency + Thing[3]
Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
Thing[6] = Thing[6] + Thing[5]
end
else
Part.Parent = nil
table.remove(Effects, e)
end
end
end
end
end
end
-------------------------------------------------------
--End Animations And Script--
 -------------------------------------------------------
end)

c:CreateButton("Trap Rifle",function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    function LoadLibrary(a)
        return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
    end
    wait(1/60)
    Effects = { }
    local Player = game:service'Players'.localPlayer
    local chara = Player.Character.Shiba
    local Humanoid = chara:FindFirstChildOfClass("Humanoid")
    local Mouse = Player:GetMouse()
    local LeftArm = chara["Left Arm"]
    local RightArm = chara["Right Arm"]
    local LeftLeg = chara["Left Leg"]
    local RightLeg = chara["Right Leg"]
    local Head = chara.Head
    local Torso = chara.Torso
    local Camera = workspace.CurrentCamera
    local RootPart = chara.HumanoidRootPart
    local RootJoint = RootPart.RootJoint
    local attack = false
    local Anim = 'Idle'
    local attacktype = 1
    local delays = false
    local play = true
    local targetted = nil
    local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
    local velocity = RootPart.Velocity.y
    local sine = 0
    local change = 1
    local doe = 0
    local Create = LoadLibrary("RbxUtility").Create
    local debby = game:GetService("Debris")
    Humanoid.WalkSpeed = 16
    
    Humanoid.Animator.Parent = nil
    chara.Animate.Parent = nil
    
    local newMotor = function(part0, part1, c0, c1)
    local w = Create('Motor'){
    Parent = part0,
    Part0 = part0,
    Part1 = part1,
    C0 = c0,
    C1 = c1,
    }
    return w
    end
    
    function clerp(a, b, t)
    return a:lerp(b, t)
    end
    
    RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
    NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    
    local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
    local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
    local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
    local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
    RootJoint.C1 = CFrame.new(0, 0, 0)
    RootJoint.C0 = CFrame.new(0, 0, 0)
    Torso.Neck.C1 = CFrame.new(0, 0, 0)
    Torso.Neck.C0 = CFrame.new(0, 1.5, 0)
    
    local rarmc1 = RW.C1
    local larmc1 = LW.C1
    local rlegc1 = RH.C1
    local llegc1 = LH.C1
    
    local resetc1 = false
    
    function PlayAnimationFromTable(table, speed, bool)
    RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
    Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
    RW.C0 = clerp(RW.C0, table[3], speed) 
    LW.C0 = clerp(LW.C0, table[4], speed) 
    RH.C0 = clerp(RH.C0, table[5], speed) 
    LH.C0 = clerp(LH.C0, table[6], speed) 
    if bool == true then
    if resetc1 == false then
    resetc1 = true
    RootJoint.C1 = RootJoint.C1
    Torso.Neck.C1 = Torso.Neck.C1
    RW.C1 = rarmc1
    LW.C1 = larmc1
    RH.C1 = rlegc1
    LH.C1 = llegc1
    end
    end
    end
    
    ArtificialHB = Instance.new("BindableEvent", script)
    ArtificialHB.Name = "Heartbeat"
    script:WaitForChild("Heartbeat")
    frame = 0.03333333333333
    tf = 0
    allowframeloss = false
    tossremainder = false
    lastframe = tick()
    script.Heartbeat:Fire()
    game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
    if allowframeloss then
    script.Heartbeat:Fire()
    lastframe = tick()
    else
    for i = 1, math.floor(tf / frame) do
    script.Heartbeat:Fire()
    end
    lastframe = tick()
    end
    if tossremainder then
    tf = 0
    else
    tf = tf - frame * math.floor(tf / frame)
    end
    end
    end)
    function swait(num)
    if num == 0 or num == nil then
    ArtificialHB.Event:wait()
    else
    for i = 0, num do
    ArtificialHB.Event:wait()
    end
    end
    end
    
    function RemoveOutlines(part)
    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
    end
    
    function so(id,par,pit,vol)
    local sou = Instance.new("Sound", par or workspace)
    if par == chara then
    sou.Parent = chara.Torso
    end
    sou.Volume = vol
    sou.Pitch = pit or 1
    sou.SoundId = "rbxassetid://" .. id
    sou.PlayOnRemove = true
    sou:Destroy()
    end
    
    --This is just for builds--
    New = function(Object, Parent, Name, Data)
    local Object = Instance.new(Object)
    for Index, Value in pairs(Data or {}) do
    Object[Index] = Value
    end
    Object.Parent = Parent
    Object.Name = Name
    return Object
    end
    LuvGun = New("Model",chara,"LuvGun",{})
    Handle = New("Part",LuvGun,"Handaru",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199999809, 1.10000002, 0.50000006),CFrame = CFrame.new(-55.7999725, 3.16094255, -23.6752853, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    HWeld = New("ManualWeld",Handle,"HWeld",{Part0 = Handle,Part1 = RightArm,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),C1 = CFrame.new(-0.164215088, -1.07379532, 0.339058399, -1, 0, 0, 0, 0, -1, -0, -1, -0),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -22.25, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.56618547, 1.17111206, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -22.0499992, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.60091519, 1.36807442, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999994278, 0.600000024, 0.600000024),CFrame = CFrame.new(-55.7999611, 2.34997582, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),C1 = CFrame.new(1.14440918e-05, -0.577195883, 1.39673233, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.700000048, 0.199999988),CFrame = CFrame.new(-55.6999779, 4.59997463, -23.2499962, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),C1 = CFrame.new(0.0999946594, 1.49102044, 0.168943405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.100000001, 0.800000012),CFrame = CFrame.new(-55.849968, 4.39997292, -20.2000103, 0, -1, 0, 0, 0, -1.00000012, 1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, 1, -1, 0, 0, 0, -1, 0),C1 = CFrame.new(-0.0499954224, 1.82368135, 3.20732307, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.100000001, 0.199999988),CFrame = CFrame.new(-55.7999725, 4.59997463, -23.5499954, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(0.200000003, 1, 1),MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),C1 = CFrame.new(0, 1.43892598, -0.126499176, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    ShotPt = New("Part",LuvGun,"ShotPt",{Transparency = 1,Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999983624, 0.100000001, 0.100000001),CFrame = CFrame.new(-55.7999687, 3.84997725, -19.3500118, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
    Weld = New("ManualWeld",ShotPt,"Weld",{Part0 = ShotPt,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.42964172, 4.13991356, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399998486, 0.400000006, 0.100000001),CFrame = CFrame.new(-55.9499664, 3.89997602, -22.4000187, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(1.20000005, 1, 1.20000005),MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(-0.149993896, 0.949253559, 1.12756157, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Lily white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.599999428, 0.800000072, 0.600000024),CFrame = CFrame.new(-55.7999611, 2.79997706, -22.4000034, -1, 0, 0, 0, 1.00000012, 0, 0, 0, -1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.929412, 0.917647, 0.917647),})
    Mesh = New("CylinderMesh",Part,"Mesh",{})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(1.14440918e-05, -0.134031534, 1.31858826, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{Transparency = 1,Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.600000024, 0.5, 0.600000024),CFrame = CFrame.new(-55.7999611, 2.79997706, -22.4000034, -1, 0, 0, 0, 1.00000012, 0, 0, 0, -1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
    Mesh = New("CylinderMesh",Part,"Mesh",{})
    
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(1.14440918e-05, -0.134031534, 1.31858826, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.100000001, 0.800000012),CFrame = CFrame.new(-55.7499695, 4.39997292, -20.2000103, 0, 1, 0, 0, 0, -1.00000012, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 0),C1 = CFrame.new(0.0500030518, 1.82368135, 3.20732307, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.700000048, 0.199999988),CFrame = CFrame.new(-55.899971, 4.59997463, -23.2499962, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),C1 = CFrame.new(-0.0999984741, 1.49102044, 0.168943405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199999422, 0.400000006, 0.600000024),CFrame = CFrame.new(-55.7999611, 3.39997506, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),C1 = CFrame.new(1.14440918e-05, 0.456851482, 1.21440125, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 1.70000017),CFrame = CFrame.new(-55.649971, 3.84997725, -24.8499966, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(0.150001526, 0.474580526, -1.27651405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(3.8999989, 0.400000006, 0.400000006),CFrame = CFrame.new(-55.7999687, 3.89997602, -22.0499992, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.01003361, 1.47226334, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.90000045, 0.100000001, 0.0999998972),CFrame = CFrame.new(-55.5999718, 3.44997501, -21.1500034, 0, 1, 0, 0, 0, 1.00000012, 1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0),C1 = CFrame.new(0.200000763, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),CFrame = CFrame.new(-55.9499664, 3.84997725, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(-0.149993896, 0.318296194, -2.16284752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.100000001, 1.89999998),CFrame = CFrame.new(-55.7999687, 3.44997501, -21.1500034, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.499999911, 0.100000001),CFrame = CFrame.new(-55.9499664, 3.54997826, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(-0.149993896, 0.022854805, -2.11075401, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999994278, 0.600000024, 0.600000024),CFrame = CFrame.new(-55.7999611, 3.24997807, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),C1 = CFrame.new(1.14440918e-05, 0.309133291, 1.240448, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),CFrame = CFrame.new(-55.9499664, 3.24997902, -25.7500019, 0, 0, -1, 0, -1.00000012, -0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1, 0, -1, -0, -0),C1 = CFrame.new(-0.149993896, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),CFrame = CFrame.new(-55.649971, 3.24997902, -25.7500019, 0, 0, -1, 0, -1.00000012, -0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1, 0, -1, -0, -0),C1 = CFrame.new(0.150001526, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399998367, 0.300000012, 0.400000006),CFrame = CFrame.new(-55.7999687, 3.84997725, -19.6000099, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(1, 1.20000005, 1),MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.38622999, 3.893713, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.299998373, 0.300000012, 0.400000006),CFrame = CFrame.new(-55.7999687, 3.84997702, -19.9500103, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.3254528, 3.5490303, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.499999911, 0.100000001),CFrame = CFrame.new(-55.649971, 3.54997826, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(0.150001526, 0.022854805, -2.11075401, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.399999976, 0.100000001),CFrame = CFrame.new(-55.7999687, 3.39394569, -22.9842033, 1, 0, 0, 0, 0.939692855, 0.342019945, 0, -0.342019945, 0.939692855),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),C1 = CFrame.new(3.81469727e-06, 0.349468231, 0.64012146, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999983624, 0.300000012, 0.400000006),CFrame = CFrame.new(-55.7999687, 3.84997654, -19.4500065, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
    Mesh = New("SpecialMesh",Part,"Mesh",{Scale = Vector3.new(1.10000002, 1, 1),MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.41227698, 4.04143715, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.100000001, 0.5, 0.100000001),CFrame = CFrame.new(-55.7999687, 3.24997902, -23.2000008, -1, 0, 0, 0, 0, 1.00000012, 0, 1.00000012, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0),C1 = CFrame.new(3.81469727e-06, 0.170215845, 0.452602386, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.399999797, 0.399999917, 3.89999962),CFrame = CFrame.new(-55.7999687, 3.69997907, -22.0500031, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 0.81307435, 1.50698853, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199999809, 0.0999999121, 0.100000001),CFrame = CFrame.new(-55.7999687, 3.24997902, -25.7500019, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),CFrame = CFrame.new(-55.649971, 3.84997725, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(0.150001526, 0.318296194, -2.16284752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.199998379, 0.200000018, 0.400000006),CFrame = CFrame.new(-55.7999687, 3.59997559, -20.0000114, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Cylinder,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),C1 = CFrame.new(3.81469727e-06, 1.07056713, 3.54320145, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0999998078, 0.0999998972, 1.70000017),CFrame = CFrame.new(-55.9499702, 3.84997702, -24.8499966, 1, 0, 0, 0, 1, -3.7252903e-07, 0, 3.7252903e-07, 1),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(-0.149997711, 0.474580288, -1.27651405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.5, 0.300000012, 1.89999998),CFrame = CFrame.new(-55.7999687, 3.64997578, -21.1500034, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 0.920113564, 2.40199661, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.5, 0.20000115),CFrame = CFrame.new(-55.7999687, 4.16505194, -21.5144958, 1, 0, 0, 0, 0.939692855, 0.342019945, 0, -0.342019945, 0.939692855),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),C1 = CFrame.new(3.81469727e-06, 1.36407137, 1.95359993, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 2.10000134),CFrame = CFrame.new(-55.7999687, 4.39997292, -22.5499954, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.41561127, 0.893039703, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.300000012, 0.20000115),CFrame = CFrame.new(-55.7999649, 4.14997578, -23.5, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(7.62939453e-06, 1.00444555, 0.00087928772, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -21.6500015, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.67037416, 1.76199532, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -21.8499985, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.63564491, 1.56503677, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -22.4499969, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.53145647, 0.974153519, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.49997282, -22.6499939, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.49672723, 0.777194977, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),CFrame = CFrame.new(-55.7999687, 4.4999733, -22.8499947, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.4, 0.8),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(0.800000012, 0.5, 0.800000012),})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),C1 = CFrame.new(3.81469727e-06, 1.46199775, 0.58023262, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    Part = New("Part",LuvGun,"Part",{BrickColor = BrickColor.new("Carnation pink"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(1.90000045, 0.100000001, 0.0999998972),CFrame = CFrame.new(-55.9999657, 3.44997501, -21.1500034, 0, -1, 0, 0, 0, 1.00000012, -1.00000012, 0, 0),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(1, 0.596078, 0.862745),})
    Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Wedge,})
    Weld = New("ManualWeld",Part,"Weld",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 1, 0),C1 = CFrame.new(-0.199993134, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),})
    ---------------------------
    
    function rayCast(Position, Direction, Range, Ignore)
    return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
    end 
    
    function FindNearestTorso(Position, Distance, SinglePlayer)
    if SinglePlayer then
    return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
    end
    local List = {}
    for i, v in pairs(workspace:GetDescendants()) do
    if v:IsA("Model") then
    if v:findFirstChild("Head") then
    if v ~= chara then
    if (v.Head.Position - Position).magnitude <= Distance then
    table.insert(List, v)
    end 
    end 
    end 
    end 
    end
    return List
    end
    
    EffectModel = Create("Model"){
    Parent = chara,
    Name = "Effects",
    }
    
    game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
    local function align(part0, part1)
        attachment = Instance.new("Attachment", part0)
        attachment.Position = Vector3.new(0.3, -0.7, 0.1) -- positioning
        attachment.Orientation = Vector3.new(15, -90, -15) -- orienation/rotation
        
        attachment02 = Instance.new("Attachment", part1) -- arm or part
        
        lol = Instance.new("AlignPosition", part0)
        lol.Attachment0 = attachment
        lol.Attachment1 = attachment02
        lol.MaxForce = math.huge
        lol.RigidityEnabled = true -- makes it not wobbly
        
        pog = Instance.new("AlignOrientation", part0)
        pog.Attachment0 = attachment
        pog.Attachment1 = attachment02
        pog.Responsiveness = 20
        pog.RigidityEnabled = true-- makes it not wobbly
    end
    align(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, Handle)
    --Effect Functions--
    Effects = {
    
    Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = partsize
    p.Anchored = true
    p.CanCollide = false
    p.Material = matr
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("BlockMesh",p)
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    if spin == true then
    p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
    end
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = partsize
    p.Anchored = true
    p.CanCollide = false
    p.Material = matr
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("SpecialMesh",p)
    m.MeshType = "Sphere"
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = partsize
    p.Anchored = true
    p.CanCollide = false
    p.Material = matr
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("CylinderMesh",p)
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = Vector3.new()
    p.Anchored = true
    p.CanCollide = false
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("SpecialMesh",p)
    m.MeshId = "rbxassetid://20329976"
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = Vector3.new()
    p.Anchored = true
    p.CanCollide = false
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("SpecialMesh",p)
    m.MeshId = "rbxassetid://3270017"
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = Vector3.new()
    p.Anchored = true
    p.CanCollide = false
    p.CFrame = cf
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("SpecialMesh",p)
    m.MeshId = meshid
    m.TextureId = textid
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
    end
    p:Destroy()
    end)()
    return p
    end,
    
    Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
    local p = Instance.new("Part",EffectModel)
    p.BrickColor = BrickColor.new(colour)
    p.Size = partsize
    p.Anchored = true
    p.CanCollide = false
    p.Material = matr
    p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
    if inverse == true then
    p.Transparency = 1
    else
    p.Transparency = 0
    end
    local m = Instance.new("SpecialMesh",p)
    m.MeshType = "Sphere"
    m.Scale = meshstart
    coroutine.wrap(function()
    for i=0,1,factor do
    swait()
    if inverse == true then
    p.Transparency = 1-i
    else
    p.Transparency = i
    end
    m.Scale = m.Scale + meshadd
    p.CFrame = p.CFrame * CFrame.new(0,move,0)
    end
    p:Destroy()
    end)()
    return p
    end,
    
    }
    
    function GetDudesTorso(c)
    local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
    if torsy ~= nil then
    return torsy
    end
    end
    
    function BodyVel(part,faws)
    local bodyvel = Instance.new("BodyVelocity",part)
    local pep = 10000000
    bodyvel.P = pep
    bodyvel.MaxForce = Vector3.new(pep,pep,pep)
    bodyvel.Velocity = faws
    debby:AddItem(bodyvel,.2)
    end
    
    
    function MagnitudeDmg(par,magni)
    
    end
    
    local mus = Instance.new("Sound",Head)
    mus.Name = "mus"
    mus.SoundId = "rbxassetid://1131624146"
    mus.Looped = true
    mus.Volume = 1
    mus:Play()
    
    zhold = false
    function shoot()
    attack = true
    for i=0,1,.3 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
    CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
    CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
    CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
    CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
    CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
    }, .4, false)
    end
    Humanoid.WalkSpeed = 2
    local ref = Instance.new("Part",chara)
    ref.Size = Vector3.new(0,0,0)
    ref.Anchored = true
    ref.CanCollide = false
    ref.Transparency = 1
    repeat
    so(1145251796,ShotPt,math.random(95,105)/100,3)
    ref.CFrame = Mouse.Hit
    MagnitudeDmg(ref,2)
    Effects.Block(ShotPt.CFrame,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
    Effects.Block(CFrame.new((ShotPt.Position + Mouse.Hit.p)/2,Mouse.Hit.p),Vector3.new(1,1,(ShotPt.Position - Mouse.Hit.p).magnitude),Vector3.new(.2,.2,1),Vector3.new(.1,.1,0),"Neon","Pink",false,false,.1)
    Effects.Block(Mouse.Hit,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
    for i=0,1,.5 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
    CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
    CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
    CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
    CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
    CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
    }, .4, false)
    end
    for i=0,1,.5 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
    CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
    CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
    CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
    CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
    CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
    }, .4, false)
    end
    until zhold == false
    ref:Destroy()
    Humanoid.WalkSpeed = 16
    attack = false
    end
    
    function doge()
    attack = true
    Humanoid.WalkSpeed = 0
    so(536642316,Torso,1,1)
    local bodyvel = Instance.new("BodyVelocity",RootPart)
    local pep = 10000000
    bodyvel.P = pep
    bodyvel.MaxForce = Vector3.new(pep,pep,pep)
    bodyvel.Velocity = RootPart.CFrame.lookVector*50
    for i=0,1,.2 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
    CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    }, .4, false)
    bodyvel.Velocity = RootPart.CFrame.lookVector*50
    end
    for i=0,1,.2 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
    CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    }, .4, false)
    bodyvel.Velocity = RootPart.CFrame.lookVector*50
    end
    for i=0,1,.2 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
    CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
    CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
    }, .4, false)
    bodyvel.Velocity = RootPart.CFrame.lookVector*50
    end
    bodyvel:Destroy()
    Humanoid.WalkSpeed = 16
    attack = false
    end
    
    function bdoge()
    attack = true
    Humanoid.WalkSpeed = 0
    so(536642316,Torso,1,1)
    local bodyvel = Instance.new("BodyVelocity",RootPart)
    local pep = 10000000
    bodyvel.P = pep
    bodyvel.MaxForce = Vector3.new(pep,pep,pep)
    bodyvel.Velocity = RootPart.CFrame.lookVector*-50
    for i=0,1,.2 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
    CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
    CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
    }, .4, false)
    bodyvel.Velocity = RootPart.CFrame.lookVector*-50
    end
    for i=0,1,.2 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
    CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
    }, .4, false)
    bodyvel.Velocity = RootPart.CFrame.lookVector*-50
    end
    bodyvel:Destroy()
    Humanoid.WalkSpeed = 16
    attack = false
    end
    
    function adoge()
    attack = true
    Humanoid.WalkSpeed = 0
    so(536642316,Torso,1,1)
    Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
    BodyVel(RootPart,RootPart.CFrame.lookVector*50)
    for i=0,1,.1 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
    CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
    CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438),
    }, .4, false)
    end
    Humanoid.WalkSpeed = 16
    attack = false
    end
    
    function badoge()
    attack = true
    Humanoid.WalkSpeed = 0
    so(536642316,Torso,1,1)
    Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(-90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
    BodyVel(RootPart,RootPart.CFrame.lookVector*-50)
    for i=0,1,.1 do
    swait()
    PlayAnimationFromTable({		
    CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
    CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
    CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
    }, .4, false)
    end
    Humanoid.WalkSpeed = 16
    attack = false
    end
    
    Mouse.Button1Down:connect(function()
    if attack == false then
    zhold = true
    shoot()
    end
    end)
    
    Mouse.Button1Up:connect(function()
    zhold = false
    end)
    
    local sprintt = 0
    Mouse.KeyDown:connect(function(k)
    k = k:lower()
    if k=='m' then
    if mus.IsPlaying == true then
    mus:Stop()
    elseif mus.IsPaused == true then
    mus:Play()
    end
    end
    if attack == false then
    if k == 'q' then
    if Anim == "Fall" or Anim == "Jump" then
    badoge()
    else
    bdoge()
    end
    elseif k == 'e' then
    if Anim == "Fall" or Anim == "Jump" then
    adoge()
    else
    doge()
    end
    end
    end
    end)
    
    Mouse.KeyUp:connect(function(k)
    k = k:lower()
    if k == 'z' then
    zhold = false
    end
    end)
    for i, v in pairs(LuvGun:GetChildren()) do
        v.Transparency = 1
    end
    
    coroutine.wrap(function()
    while 1 do
    swait()
    if doe <= 360 then
    doe = doe + 2
    else
    doe = 0
    end
    end
    end)()
    while true do
    swait()
    while true do
    swait()
    if Head:FindFirstChild("mus")==nil then
    mus = Instance.new("Sound",Head)
    mus.Name = "mus"
    mus.SoundId = "rbxassetid://1131624146"
    mus.Looped = true
    mus.Volume = 1
    mus:Play()
    end
    if sprintt >= 1 then
    sprintt = sprintt - 1
    end
    Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    velocity = RootPart.Velocity.y
    sine = sine + change
    local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
    if RootPart.Velocity.y > 1 and hit == nil then 
    Anim = "Jump"
    if attack == false then
    PlayAnimationFromTable({
    CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
    CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
    CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
    CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
    CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
    CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
    }, .3, false)
    end
    elseif RootPart.Velocity.y < -1 and hit == nil then 
    Anim = "Fall"
    if attack == false then
    PlayAnimationFromTable({
    CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
    CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
    CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
    CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
    CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
    CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
    }, .3, false)
    end
    elseif Torsovelocity < 1 and hit ~= nil then
    Anim = "Idle"
    if attack == false then
    change = 1
    PlayAnimationFromTable({
    CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
    CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
    CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
    }, .3, false)
    end
    elseif Torsovelocity > 2 and hit ~= nil then
    Anim = "Walk"
    if attack == false then
    Humanoid.WalkSpeed = 16
    PlayAnimationFromTable({
    CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, 0, 0),
    CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
    CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
    CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
    CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
    CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
    }, .3, false)
    end
    end
    end
    end
end)

c:CreateButton("Banzai Bazooka", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
    local script = game:GetObjects("rbxassetid://6730580482")[1]

    local MODULE = script
    local CHARACTER = game.Players.LocalPlayer.Character.Shiba
    local PLAYER = game.Players.LocalPlayer
    local HUM = CHARACTER.Humanoid
    local REMOTE = MODULE.Event
    
    local ROOT = HUM.Torso
    local HEAD = CHARACTER.Head
    local TORSO = CHARACTER.Torso
    local RIGHTARM = CHARACTER["Right Arm"]
    local LEFTARM = CHARACTER["Left Arm"]
    local RIGHTLEG = CHARACTER["Right Leg"]
    local LEFTLEG = CHARACTER["Left Leg"]
    local ROOTJOINT = ROOT["RootJoint"]
    local NECK = TORSO["Neck"]
    local RIGHTSHOULDER = TORSO["Right Shoulder"]
    local LEFTSHOULDER = TORSO["Left Shoulder"]
    local RIGHTHIP = TORSO["Right Hip"]
    local LEFTHIP = TORSO["Left Hip"]
    local MOUSEPOS = ROOT.Position
    
    IT = Instance.new
    CF = CFrame.new
    VT = Vector3.new
    RAD = math.rad
    C3 = Color3.new
    UD2 = UDim2.new
    BRICKC = BrickColor.new
    ANGLES = CFrame.Angles
    EULER = CFrame.fromEulerAnglesXYZ
    COS = math.cos
    ACOS = math.acos
    SIN = math.sin
    ASIN = math.asin
    ABS = math.abs
    MRANDOM = math.random
    FLOOR = math.floor
    
    --//====================================================\\--
    --||                       FE CODE
    --\\====================================================//--
    
    local owner = game.Players.LocalPlayer
    local Player = owner
    local Mouse,mouse,UserInputService,ContextActionService = game.Players.LocalPlayer:GetMouse(),game.Players.LocalPlayer:GetMouse(),game:GetService("UserInputService"),game:GetService("ContextActionService")
    
    
    local function align(part0, part1)
        attachment = Instance.new("Attachment", part0)
        attachment.Position = Vector3.new(0.3, 0, 0) -- positioning
        attachment.Orientation = Vector3.new(-45, 90, 0) -- orienation/rotation
    
        attachment02 = Instance.new("Attachment", part1) -- arm or part
    
        lol = Instance.new("AlignPosition", part0)
        lol.Attachment0 = attachment
        lol.Attachment1 = attachment02
        lol.MaxForce = 67734
        lol.RigidityEnabled = true -- makes it not wobbly
    
        pog = Instance.new("AlignOrientation", part0)
        pog.Attachment0 = attachment
        pog.Attachment1 = attachment02
        pog.Responsiveness = 200
        pog.RigidityEnabled = true-- makes it not wobbly
    end
    game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle:BreakJoints()
    align(game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle, script.Bazooka)
    script.Bazooka.Transparency = 1
    
    --//====================================================\\--
    --||                  BACKGROUND VALUES
    --\\====================================================//--
    
    local ANIM_SPEED = 3
    local MOUSE = PLAYER:GetMouse()
    local MOUSEPOS = Mouse.Hit.p
    local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
    local CHANGE = 2 / ANIM_SPEED
    local DAMAGEMULTIPLIER = 1
    local ANIM = "Idle"
    local KEYHOLD = false
    local MOUSEHOLD = false
    local SINE = 0
    local ATTACKING = false
    local Debris = game:GetService("Debris")
    local Effects = IT("Folder",CHARACTER)
    Effects.Name = "FXFolder"
    local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
    local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
    local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
    local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
    local BGM = 213546066
    local BOMB = 2671146857
    local STORED = 9999999999999
    
    --//====================================================\\--
    --||                     HEARTBEAT
    --\\====================================================//--
    
    ArtificialHB = Instance.new("BindableEvent", script)
    ArtificialHB.Name = "ArtificialHB"
    
    script:WaitForChild("ArtificialHB")
    
    frame = FRAME_SPEED
    tf = 0
    allowframeloss = false
    tossremainder = false
    lastframe = tick()
    script.ArtificialHB:Fire()
    
    game:GetService("RunService").Heartbeat:connect(function(s, p)
        tf = tf + s
        if tf >= frame then
            if allowframeloss then
                ArtificialHB:Fire()
                lastframe = tick()
            else
                for i = 1, math.floor(tf / frame) do
                    ArtificialHB:Fire()
                end
                lastframe = tick()
            end
            if tossremainder then
                tf = 0
            else
                tf = tf - frame * math.floor(tf / frame)
            end
        end
    end)
    
    function PositiveAngle(NUMBER)
        if NUMBER >= 0 then
            NUMBER = 0
        end
        return NUMBER
    end
    
    function NegativeAngle(NUMBER)
        if NUMBER <= 0 then
            NUMBER = 0
        end
        return NUMBER
    end
    
    function Swait(NUMBER)
        if NUMBER == 0 or NUMBER == nil then
            ArtificialHB.Event:wait()
        else
            for i = 1, NUMBER do
                ArtificialHB.Event:wait()
            end
        end
    end
    
    --//====================================================\\--
    --||                       CLERP
    --\\====================================================//--
    
    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then 
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m11 > m00 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end
     
    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end
     
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp;
        if cosTheta >= 0.0001 then
            if (1 - cosTheta) > 0.0001 then
                local theta = ACOS(cosTheta)
                local invSinTheta = 1 / SIN(theta)
                startInterp = SIN((1 - t) * theta) * invSinTheta
                finishInterp = SIN(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        else
            if (1 + cosTheta) > 0.0001 then
                local theta = ACOS(-cosTheta)
                local invSinTheta = 1 / SIN(theta)
                startInterp = SIN((t - 1) * theta) * invSinTheta
                finishInterp = SIN(t * theta) * invSinTheta
            else
                startInterp = t - 1
                finishInterp = t
            end
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end
    
    function Clerp(a, b, t)
        local qa = {QuaternionFromCFrame(a)}
        local qb = {QuaternionFromCFrame(b)}
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
    
    --//====================================================\\--
    --||                     FUNCTIONS
    --\\====================================================//--
    
    function WeldParts(A,B)
        local WLD = IT("ManualWeld")
        WLD.Part0 = A
        WLD.Part1 = B
        WLD.C1 = B.CFrame:inverse() * A.CFrame
        WLD.Parent = A
        return WLD
    end
    
    --NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
    function NewSound(TABLE)
        local ID = "rbxassetid://"..(TABLE.ID or 0)
        local PARENT = (TABLE.PARENT or ROOT)
        local VOLUME = (TABLE.VOLUME or 0.5)
        local PITCH = (TABLE.PITCH or 1)
        local LOOP = (TABLE.LOOP or false)
        local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
        local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
        local PLAYING = (TABLE.PLAYING or true)
        local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
        local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
        if ID ~= "rbxassetid://0" then
            local SOUND = IT("Sound",PARENT)
            SOUND.SoundId = ID
            SOUND.Volume = VOLUME
            SOUND.Pitch = PITCH
            SOUND.Looped = LOOP
            SOUND.MaxDistance = MAXDISTANCE
            SOUND.EmitterSize = EMITTERSIZE
            SOUND.PlayOnRemove = PLAYONREMOVE
            if DOESDEBRIS == true and PLAYING == true and LOOP == false then
                Debris:AddItem(SOUND,SOUND.TimeLength+5)
            end
            if PLAYING == true then
                SOUND:Play()
            end
            return SOUND
        end
    end
    
    function ManSlaughter(MAN)
    return
    end
    
    function AreaOfEffect(AREA,RANGE,FLING,RETURN)
        local HIT = {}
        for index, CHILD in pairs(workspace:GetChildren()) do
            if CHILD:FindFirstChildOfClass("Humanoid") then
                local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
                local ROOT = HUMAN.Torso
                if ROOT then
                    if (ROOT.Position - AREA).Magnitude <= RANGE then
                        if RETURN == true then
                            if CHILD ~= CHARACTER then
                                table.insert(HIT,{CHILD,HUMAN,ROOT})
                            end
                        else
                            if CHILD ~= CHARACTER then
                                ManSlaughter(CHILD)
                            end
    
                        end
                    end
                end
            end
        end
        if RETURN == true then
            return HIT
        end
    end
    
    function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
        local NEWPART = IT("Part")
        NEWPART.formFactor = FORMFACTOR
        NEWPART.Reflectance = REFLECTANCE
        NEWPART.Transparency = TRANSPARENCY
        NEWPART.CanCollide = false
        NEWPART.Locked = true
        NEWPART.Anchored = true
        if ANCHOR == false then
            NEWPART.Anchored = false
        end
        NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
        NEWPART.Name = NAME
        NEWPART.Size = SIZE
        NEWPART.Position = ROOT.Position
        NEWPART.Material = MATERIAL
        NEWPART:BreakJoints()
        NEWPART.Parent = PARENT
        return NEWPART
    end
    
    function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
        return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
    end
    
    function CameraShake(AREA,RANGE,SHAKE,TIMER)
        for index, CHILD in pairs(workspace:GetChildren()) do
            if CHILD:FindFirstChildOfClass("Humanoid") then
                local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
                local ROOT = HUMAN.Torso
                if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
                    if (ROOT.Position - AREA).Magnitude <= RANGE then
                        if CHILD:FindFirstChild("CamShake") then
                            Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
                        end
                        local CAMSHAKE = script.CamShake:Clone()
                        CAMSHAKE.Parent = CHILD
                        local TIMER_V = IT("NumberValue",CAMSHAKE)
                        TIMER_V.Name = "Timer"
                        TIMER_V.Value = TIMER
                        local SHAKE_V = IT("NumberValue",CAMSHAKE)
                        SHAKE_V.Name = "Shake"
                        SHAKE_V.Value = SHAKE
                        CAMSHAKE.Disabled = false
                        Debris:AddItem(CAMSHAKE,15)
                    end
                end
            end
        end
    end
    
    --//====================================================\\--
    --||                     CHARACTER
    --\\====================================================//--
    
    local HELMET = MODULE.Helmet
    HELMET.Parent = CHARACTER
    for index, CHILD in pairs(CHARACTER:GetChildren()) do
        if CHILD ~= ROOT then
            if CHILD:IsA("Accessory") then
                
            end
        end
    end
    
    HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
    HELMET.Anchored = false
    WeldParts(HEAD,HELMET)
    local BAZOOKA = MODULE.Bazooka
    BAZOOKA.Parent = CHARACTER
    BAZOOKA.Anchored = false
    local GRIP = IT("Motor6D")
    GRIP.Part0 = RIGHTARM
    GRIP.Part1 = BAZOOKA
    GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
    local G_C0 = GRIP.C0
    GRIP.Parent = RIGHTARM
    for i = 1, 15 do
        local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
        FACE.Color = C3(0,0,0)
        HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
        FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
        WeldParts(HEAD,FACE)
    end
    local MISSILE = MODULE.Missile
    MISSILE.Parent = nil
    local GUI = MODULE.ControlsGUI
    GUI.Parent = PLAYER.PlayerGui
    GUI.ToggleButton.MouseButton1Click:Connect(function()
        if GUI.ToggleButton.Controls.Visible == false then
            GUI.ToggleButton.Controls.Visible = true
        elseif GUI.ToggleButton.Controls.Visible == true then
            GUI.ToggleButton.Controls.Visible = false
        end
    end)
    local STOREDGUI = GUI.ToggleButton.Stored
    STOREDGUI.Text = "STORED: "..STORED
    function AddTo(ADD)
        STORED = STORED + ADD
        STOREDGUI.Text = "STORED: "..STORED
    end
    
    --//====================================================\\--
    --||                     ABILITIES
    --\\====================================================//--
    
    function Fire_in_the_hole()
        if STORED > 0 then
            ATTACKING = true
            local GYRO = IT("BodyGyro")
            GYRO.D = 50
            GYRO.P = 5000
            GYRO.MaxTorque = VT(0,4000000,0)
            GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
            GYRO.Parent = ROOT
            ATTACKING = true
            coroutine.resume(coroutine.create(function()
                repeat
                    Swait()
                    GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
                until ATTACKING == false
                GYRO:Remove()
            end))
            repeat
                for i=0, 0.06, 0.1 / ANIM_SPEED do
                    Swait()
                    ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
                    NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                    RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                    LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
                    RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                    LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                end
                AddTo(-1)
                coroutine.resume(coroutine.create(function()
                    local GOTO = Mouse.Hit.p
                    local ROCKET = MISSILE:Clone()
                    ROCKET.Parent = Effects
                    ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
                    NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                    NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                    for i = 1, 200 do
                        Swait()
                        local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
                        if HIT then
                            ROCKET.CFrame = CF(POS)
                            break
                        end
                        ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
                    end
                    ROCKET.Transparency = 1
                    ROCKET.Hind:Remove()
                    ROCKET.CFrame = CF(ROCKET.Position)
                    ROCKET.Size = VT(0,0,0)
                    NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                    for index, CHILD in pairs(script.Grenade:GetChildren()) do
                        local C = CHILD:Clone()
                        C.Parent = ROCKET
                        C:Emit(125)
                    end
                    CameraShake(ROCKET.Position,50,125,70)
                    AreaOfEffect(ROCKET.Position,35,200,false)
                    Debris:AddItem(ROCKET,2)
                end))
                for i=0, 0.025, 0.1 / ANIM_SPEED do
                    Swait()
                    ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
                    NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                    RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                    LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
                    RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                    LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
                end
            until MOUSEHOLD == false or STORED <= 0
            if STORED <= 0 then
                STORED = 0
                STOREDGUI.Text = "STORED: 0"
            end
            ATTACKING = false
        end
    end
    function Store()
        HUM.WalkSpeed = 0
        HUM.JumpPower = 0
        ATTACKING = true
        repeat
            for i=0, 0.01, 0.1 / ANIM_SPEED do
                Swait()
                GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
                ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
                NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
                RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
                RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
                LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
            end
            local ROCKET = MISSILE:Clone()
            ROCKET.Anchored = false
            ROCKET:ClearAllChildren()
            ROCKET.CFrame = LEFTARM.CFrame*CF(0,-1,0) * ANGLES(RAD(0), RAD(90), RAD(0))
            ROCKET.Parent = CHARACTER
            WeldParts(ROCKET,LEFTARM)
            for i=0, 0.02, 0.1 / ANIM_SPEED do
                Swait()
                GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
                ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
                NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
                RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
                RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
                LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
            end
            for i=0, 0.02, 0.1 / ANIM_SPEED do
                Swait()
                GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
                ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
                NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
                RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
                RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
                LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
            end
            NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
            for i=0, 0.05, 0.1 / ANIM_SPEED do
                Swait()
                GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
                ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
                NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
                RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
                LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
                RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
                LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
            end
            ROCKET:Remove()
            BAZOOKA.Face.Pop:Emit(5)
            AddTo(1)
        until KEYHOLD == false
        ATTACKING = false
        HUM.WalkSpeed = 100
        HUM.JumpPower = 50
    end
    
    function Dance()
        HUM.WalkSpeed = 0
        HUM.JumpPower = 0
        ATTACKING = true
        local REMOVETRACK = false
        local TRACK = nil
        if ROOT:FindFirstChild("BGM_MUSIC") then
            TRACK = ROOT:FindFirstChild("BGM_MUSIC")
            TRACK.Volume = 5
        else
            TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
            REMOVETRACK = true
        end
        TRACK.SoundId = "rbxassetid://"..BOMB
        TRACK:Play()
        local DONEWITHDANCING = false
        local NC = mouse.KeyDown:connect(function(key)
            key=key:lower()
            local V2 = key
            if V2 == "m" then
                DONEWITHDANCING = true
                ATTACKING = false
                if REMOVETRACK == true then
                    TRACK:Remove()
                else
                    TRACK:Play()
                    TRACK.Volume = 1.25
                    TRACK.SoundId = "rbxassetid://"..BGM
                end
            end
        end)
        local I = 0
        local RAVE = IT("PointLight",ROOT)
        RAVE.Brightness = 25
        RAVE.Color = BrickColor.random().Color
        repeat
            I = I + 2
            Swait()
            RAVE.Color = BrickColor.random().Color
            ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
            NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
            RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
            LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
            RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
            LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
        until DONEWITHDANCING == true
        RAVE:Remove()
        NC:Disconnect()
        if REMOVETRACK == true then
            TRACK:Remove()
        else
            TRACK:Play()
            TRACK.Volume = 1.25
            TRACK.SoundId = "rbxassetid://"..BGM
        end
        ATTACKING = false
        HUM.WalkSpeed = 100
        HUM.JumpPower = 50
    end
    
    --//====================================================\\--
    --||                       WRAP
    --\\====================================================//--
    
    mouse.Button1Down:connect(function()
        MOUSEHOLD = true
        if ATTACKING == false then
            Fire_in_the_hole()
        end
    end)
    
    mouse.Button1Up:connect(function()
        MOUSEHOLD = false
    end)
    
    mouse.KeyDown:connect(function(key)
        key=key:lower()
        local V2 = key
        KEYHOLD = true
                    if V2 == "z" then
                        Store()
                    elseif V2 == "m" then
                        Dance()
                    elseif V2 == "t" then
                        NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                    elseif V2 == "e" then
                        if ROOT:FindFirstChild("BGM_MUSIC") then
                            ROOT:FindFirstChild("BGM_MUSIC"):Remove()
                        else
                            local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                            M.Name = "BGM_MUSIC"
                        end
                    end
    end)
    
    mouse.KeyUp:connect(function()
        KEYHOLD = false
    end)
    
    --[[
    REMOTE.OnClientEvent:Connect(function(PLR,V1,V2)
        if PLR == PLAYER and ANIM ~= "Sit" then
            --if V1 == "MousePositionUpdate" then
                --MOUSEPOS = V2
            if V1 == "KeyUp" then
                KEYHOLD = false
            elseif V1 == "MouseUp" then
                MOUSEHOLD = false
            end
            if ATTACKING == false then
                if V1 == "MouseDown" then
                    MOUSEHOLD = true
                    Fire_in_the_hole()
                elseif V1 == "KeyDown" then
                    KEYHOLD = true
                    if V2 == "z" then
                        Store()
                    elseif V2 == "m" then
                        Dance()
                    elseif V2 == "t" then
                        NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                    elseif V2 == "e" then
                        if ROOT:FindFirstChild("BGM_MUSIC") then
                            ROOT:FindFirstChild("BGM_MUSIC"):Remove()
                        else
                            local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
                            M.Name = "BGM_MUSIC"
                        end
                    end
                end
            end
        end
    end)
    ]]--
    
    local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
    M.Name = "BGM_MUSIC"
    HUM.WalkSpeed = 100
    while true do
        Swait()
        local MOUSEPOS = Mouse.Hit.p
        SINE = SINE + CHANGE
        if CHARACTER:FindFirstChild("Animate") then
            CHARACTER:FindFirstChild("Animate"):Destroy()
        end
        if CHARACTER:FindFirstChild("Sound") then
            CHARACTER:FindFirstChild("Sound"):Destroy()
        end
        for _,v in next, HUM:GetPlayingAnimationTracks() do
            v:Stop();
        end
        local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
        local TORSOVERTICALVELOCITY = ROOT.Velocity.y
        local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
        local WALKSPEEDVALUE = 0.5
        local SITTING = HUM.Sit
        if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
            RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
            LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
        elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
            RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
            LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
        end
        if ATTACKING == false then
            GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
        end
        if SITTING == false then
            if HITFLOOR then
                if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
                    ANIM = "Idle"
                    if ATTACKING == false then
                        ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
                        NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
                        RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
                        LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
                        RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
                        LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
                    end
                elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
                    ANIM = "Walk"
                    if ATTACKING == false then
                        ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
                        NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
                        RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
                        LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
                        RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
                        LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
                    end
                end
            else
                if TORSOVERTICALVELOCITY > 0 then
                    ANIM = "Jump"
                    if ATTACKING == false then
                        ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
                        NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
                        RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
                        LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
                        RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
                        LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
                    end
                else
                    ANIM = "Fall"
                    if ATTACKING == false then
                        ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
                        NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
                        RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
                        LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
                        RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
                        LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
                    end
                end
            end
        else
            ANIM = "Sit"
            if ATTACKING == false then
                ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
                NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
                RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
                LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
                RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
                LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
            end
        end
    end

    end)
    
    c:CreateButton("Arsenal Delinquent", function()
    if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then return end
            local script = game:GetObjects("rbxassetid://6726523130")[1]
    local Player = game.Players.LocalPlayer
    local Mouse,mouse,UserInputService,ContextActionService = game.Players.LocalPlayer:GetMouse(),game.Players.LocalPlayer:GetMouse(),game:GetService("UserInputService"),game:GetService("ContextActionService")
        
    wait(0.2)
    PlayerGui = Player.PlayerGui
    Cam = workspace.CurrentCamera
    Backpack = Player.Backpack
    Character = Player.Character.Shiba
    Humanoid = Character.Humanoid
    RootPart = Character.HumanoidRootPart
    Torso = Character.Torso
    Head = Character.Head
    RightArm = Character["Right Arm"]
    LeftArm = Character["Left Arm"]
    RightLeg = Character["Right Leg"]
    LeftLeg = Character["Left Leg"]
    RootJoint = RootPart.RootJoint
    Neck = Torso.Neck
    RightShoulder = Torso["Right Shoulder"]
    LeftShoulder = Torso["Left Shoulder"]
    RightHip = Torso["Right Hip"]
    LeftHip = Torso["Left Hip"]
    local MOUSEPOS = RootPart.Position
    local TIME = 0
    local sick = Instance.new("Sound",Torso)
    
    IT = Instance.new
    CF = CFrame.new
    VT = Vector3.new
    RAD = math.rad
    C3 = Color3.new
    UD2 = UDim2.new
    BRICKC = BrickColor.new
    ANGLES = CFrame.Angles
    EULER = CFrame.fromEulerAnglesXYZ
    COS = math.cos
    ACOS = math.acos
    SIN = math.sin
    ASIN = math.asin
    ABS = math.abs
    MRANDOM = math.random
    FLOOR = math.floor
    --//=================================\\
    --|| 	      USEFUL VALUES
    --\\=================================//
    
    Animation_Speed = 3
    Frame_Speed = 0.016666666666666666
    local FORCERESET = false
    Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
    local Speed = 25
    local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
    local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
    local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
    local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
    local DAMAGEMULTIPLIER = 1
    local ANIM = "Idle"
    local ATTACK = false
    local BMUSIC = IT("Sound", RootPart)
    local VOLUME = 2
    local PITCH = 1
    local SONGID = 1305709235  --1347700465
    local EQUIPPED = false
    local HOLD = false
    local COMBO = 1
    local Type = "Ban"
    local reason = "Ur damn skids nigga"
    local Rooted = false
    local SINE = 0
    local SIZE = 1
    local KEYHOLD = false
    local CHANGE = 2 / Animation_Speed
    local WALKINGANIM = false
    local VALUE1 = false
    local VALUE2 = false
    local ROBLOXIDLEANIMATION = IT("Animation")
    ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
    ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
    --ROBLOXIDLEANIMATION.Parent = Humanoid
    local WEAPONGUI = IT("ScreenGui", PlayerGui)
    WEAPONGUI.Name = "BanishV3Gui"
    local Characterb = IT("Model")
    Characterb.Name = "shackisgaylol"
    local CharacterA = IT("Model")
    CharacterA.Name = "shackismegagaylol"
    local Effects = IT("Folder", CharacterA)
    Effects.Name = "Effects"
    local Effects2 = IT("Folder", Characterb)
    Effects.Name = "Effects"
    local ANIMATOR = Humanoid.Animator
    local ANIMATE = Character:FindFirstChild("Animate")
    local UNANCHOR = true
    local TOBANISH = {}
    script.Parent = PlayerGui
    
    --//=================================\\
    --\\=================================//
    
    
    --//=================================\\
    --|| SAZERENOS' ARTIFICIAL HEARTBEAT
    --\\=================================//
    
    
    
    frame = Frame_Speed
    tf = 0
    allowframeloss = false
    tossremainder = false
    lastframe = tick()
    
    
    game:GetService("RunService").Heartbeat:connect(function(s, p)
        tf = tf + s
        if tf >= frame then
            if allowframeloss then
    
                lastframe = tick()
            else
                for i = 1, math.floor(tf / frame) do
                end
            lastframe = tick()
            end
            if tossremainder then
                tf = 0
            else
                tf = tf - frame * math.floor(tf / frame)
            end
        end
    end)
    
    --//=================================\\
    --\\=================================//
    
    --//=================================\\
    --|| 	      SOME FUNCTIONS
    --\\=================================//
    
    local BODY = {}
    for _, c in pairs(Character:GetDescendants()) do
        if c:IsA("BasePart") and c.Name ~= "Handle" then
            if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
                c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            end
            table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
        elseif c:IsA("JointInstance") then
            table.insert(BODY,{c,c.Parent,nil,nil,nil})
        end
    end
    for e = 1, #BODY do
        if BODY[e] ~= nil then
            local STUFF = BODY[e]
            local PART = STUFF[1]
            local PARENT = STUFF[2]
            local MATERIAL = STUFF[3]
            local COLOR = STUFF[4]
            local TRANSPARENCY = STUFF[5]
            if PART.ClassName == "Part" and PART ~= RootPart then
                PART.Material = MATERIAL
                PART.Color = COLOR
                PART.Transparency = TRANSPARENCY
            end
            PART.AncestryChanged:Connect(function()
                PART.Parent = PARENT
            end)
        end
    end
    
    function refit()
        Character.Parent = workspace
        for e = 1, #BODY do
            if BODY[e] ~= nil then
                local STUFF = BODY[e]
                local PART = STUFF[1]
                local PARENT = STUFF[2]
                local MATERIAL = STUFF[3]
                local COLOR = STUFF[4]
                local TRANSPARENCY = STUFF[5]
                if PART:IsA("BasePart") and PART ~= RootPart then
                    PART.Material = MATERIAL
                    PART.Color = COLOR
                    PART.Transparency = TRANSPARENCY+EXTRATRANS
                end
                if PART.Parent ~= PARENT then
                    Humanoid:remove()
                    PART.Parent = PARENT
                    Humanoid = IT("Humanoid",Character)
                end
            end
        end
    end
    
    function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
        return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
    end
    
    function PositiveAngle(NUMBER)
        if NUMBER >= 0 then
            NUMBER = 0
        end
        return NUMBER
    end
    
    function NegativeAngle(NUMBER)
        if NUMBER <= 0 then
            NUMBER = 0
        end
        return NUMBER
    end
    
    function Swait(NUMBER)
        game:GetService("RunService").RenderStepped:Wait()
    end
    
    function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
        local NEWMESH = IT(MESH)
        if MESH == "SpecialMesh" then
            NEWMESH.MeshType = MESHTYPE
            if MESHID ~= "nil" and MESHID ~= "" then
                NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
            end
            if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
                NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
            end
        end
        NEWMESH.Offset = OFFSET or VT(0, 0, 0)
        NEWMESH.Scale = SCALE
        NEWMESH.Parent = PARENT
        return NEWMESH
    end
    
    function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
        local NEWPART = IT("Part")
        NEWPART.formFactor = FORMFACTOR
        NEWPART.Reflectance = REFLECTANCE
        NEWPART.Transparency = TRANSPARENCY
        NEWPART.CanCollide = false
        NEWPART.Locked = true
        NEWPART.Anchored = true
        if ANCHOR == false then
            NEWPART.Anchored = false
        end
        NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
        NEWPART.Name = NAME
        NEWPART.Size = SIZE
        NEWPART.Position = Torso.Position
        NEWPART.Material = MATERIAL
        NEWPART:BreakJoints()
        NEWPART.Parent = PARENT
        return NEWPART
    end
    
        local function weldBetween(a, b)
            local weldd = Instance.new("ManualWeld")
            weldd.Part0 = a
            weldd.Part1 = b
            weldd.C0 = CFrame.new()
            weldd.C1 = b.CFrame:inverse() * a.CFrame
            weldd.Parent = a
            return weldd
        end
    
    
    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then 
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m11 > m00 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end
     
    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end
     
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp;
        if cosTheta >= 0.0001 then
            if (1 - cosTheta) > 0.0001 then
                local theta = ACOS(cosTheta)
                local invSinTheta = 1 / SIN(theta)
                startInterp = SIN((1 - t) * theta) * invSinTheta
                finishInterp = SIN(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        else
            if (1 + cosTheta) > 0.0001 then
                local theta = ACOS(-cosTheta)
                local invSinTheta = 1 / SIN(theta)
                startInterp = SIN((t - 1) * theta) * invSinTheta
                finishInterp = SIN(t * theta) * invSinTheta
            else
                startInterp = t - 1
                finishInterp = t
            end
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end
    
    function Clerp(a, b, t)
        local qa = {QuaternionFromCFrame(a)}
        local qb = {QuaternionFromCFrame(b)}
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
    
    function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
        local frame = IT("Frame")
        frame.BackgroundTransparency = TRANSPARENCY
        frame.BorderSizePixel = BORDERSIZEPIXEL
        frame.Position = POSITION
        frame.Size = SIZE
        frame.BackgroundColor3 = COLOR
        frame.BorderColor3 = BORDERCOLOR
        frame.Name = NAME
        frame.Parent = PARENT
        return frame
    end
    
    function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
        local label = IT("TextLabel")
        label.BackgroundTransparency = 1
        label.Size = UD2(1, 0, 1, 0)
        label.Position = UD2(0, 0, 0, 0)
        label.TextColor3 = TEXTCOLOR
        label.TextStrokeTransparency = STROKETRANSPARENCY
        label.TextTransparency = TRANSPARENCY
        label.FontSize = TEXTFONTSIZE
        label.Font = TEXTFONT
        label.BorderSizePixel = BORDERSIZEPIXEL
        label.TextScaled = false
        label.Text = TEXT
        label.Name = NAME
        label.Parent = PARENT
        return label
    end
    
    
    function NoOutlines(PART)
        PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
    end
    
    function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
    local weld = Instance.new("Weld")
    weld.Parent = parent
    weld.Part0 = part0
    weld.Part1 = part1
    weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
    weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
    return weld
    end
    
    --NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
    function NewSound(TABLE)
        local ID = "rbxassetid://"..(TABLE.ID or 0)
        local PARENT = (TABLE.PARENT or RootPart)
        local VOLUME = (TABLE.VOLUME or 0.5)
        local PITCH = (TABLE.PITCH or 1)
        local LOOP = (TABLE.LOOP or false)
        local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
        local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
        local PLAYING = (TABLE.PLAYING or true)
        local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
        local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
        if ID ~= "rbxassetid://0" then
            local SOUND = IT("Sound",PARENT)
            SOUND.SoundId = ID
            SOUND.Volume = VOLUME
            SOUND.Pitch = PITCH
            SOUND.Looped = LOOP
            SOUND.MaxDistance = MAXDISTANCE
            SOUND.EmitterSize = EMITTERSIZE
            SOUND.PlayOnRemove = PLAYONREMOVE
            if DOESDEBRIS == true and PLAYING == true and LOOP == false then
                Debris:AddItem(SOUND,SOUND.TimeLength+5)
            end
            if PLAYING == true then
                SOUND:Play()
            end
            return SOUND
        end
    end
    
    function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
        local NEWWELD = IT(TYPE)
        NEWWELD.Part0 = PART0
        NEWWELD.Part1 = PART1
        NEWWELD.C0 = C0
        NEWWELD.C1 = C1
        NEWWELD.Parent = PARENT
        return NEWWELD
    end
    
    local S = IT("Sound")
    function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
        local NEWSOUND = nil
        coroutine.resume(coroutine.create(function()
            NEWSOUND = S:Clone()
            NEWSOUND.Parent = PARENT
            NEWSOUND.Volume = VOLUME
            NEWSOUND.Pitch = PITCH
            NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
            NEWSOUND:play()
            if DOESLOOP == true then
                NEWSOUND.Looped = true
            else
                repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
                NEWSOUND:remove()
            end
        end))
        return NEWSOUND
    end
    
    function CFrameFromTopBack(at, top, back)
        local right = top:Cross(back)
        return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
    end
    
    --WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
    function WACKYEFFECT(Table)
        local TYPE = (Table.EffectType or "Sphere")
        local SIZE = (Table.Size or VT(1,1,1))
        local ENDSIZE = (Table.Size2 or VT(0,0,0))
        local TRANSPARENCY = (Table.Transparency or 0)
        local ENDTRANSPARENCY = (Table.Transparency2 or 1)
        local CFRAME = (Table.CFrame or Torso.CFrame)
        local MOVEDIRECTION = (Table.MoveToPos or nil)
        local ROTATION1 = (Table.RotationX or 0)
        local ROTATION2 = (Table.RotationY or 0)
        local ROTATION3 = (Table.RotationZ or 0)
        local MATERIAL = (Table.Material or "Neon")
        local COLOR = (Table.Color or C3(1,1,1))
        local TIME = (Table.Time or 45)
        local SOUNDID = (Table.SoundID or nil)
        local SOUNDPITCH = (Table.SoundPitch or nil)
        local SOUNDVOLUME = (Table.SoundVolume or nil)
        coroutine.resume(coroutine.create(function()
            local PLAYSSOUND = false
            local SOUND = nil
            local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
            if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
                PLAYSSOUND = true
                SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
            end
            EFFECT.Color = COLOR
            local MSH = nil
            if TYPE == "Sphere" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
            elseif TYPE == "Block" then
                MSH = IT("BlockMesh",EFFECT)
                MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
            elseif TYPE == "Wave" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
            elseif TYPE == "Ring" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
            elseif TYPE == "Slash" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
            elseif TYPE == "Round Slash" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
            elseif TYPE == "Swirl" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
            elseif TYPE == "Skull" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
            elseif TYPE == "Crystal" then
                MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
            end
            if MSH ~= nil then
                local MOVESPEED = nil
                if MOVEDIRECTION ~= nil then
                    MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
                end
                local GROWTH = SIZE - ENDSIZE
                local TRANS = TRANSPARENCY - ENDTRANSPARENCY
                if TYPE == "Block" then
                    EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
                else
                    EFFECT.CFrame = CFRAME
                end
                for LOOP = 1, TIME+1 do
                    Swait()
                    MSH.Scale = MSH.Scale - GROWTH/TIME
                    if TYPE == "Wave" then
                        MSH.Offset = VT(0,0,-MSH.Scale.X/8)
                    end
                    EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
                    if TYPE == "Block" then
                        EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
                    else
                        EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
                    end
                    if MOVEDIRECTION ~= nil then
                        local ORI = EFFECT.Orientation
                        EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
                        EFFECT.Orientation = ORI
                    end
                end
                if PLAYSSOUND == false then
                    EFFECT:remove()
                else
                    SOUND.Stopped:Connect(function()
                        EFFECT:remove()
                    end)
                end
            else
                if PLAYSSOUND == false then
                    EFFECT:remove()
                else
                    repeat Swait() until SOUND.Playing == false
                    EFFECT:remove()
                end
            end
        end))
    end
    
    function MakeForm(PART,TYPE)
        if TYPE == "Cyl" then
            local MSH = IT("CylinderMesh",PART)
        elseif TYPE == "Ball" then
            local MSH = IT("SpecialMesh",PART)
            MSH.MeshType = "Sphere"
        elseif TYPE == "Wedge" then
            local MSH = IT("SpecialMesh",PART)
            MSH.MeshType = "Wedge"
        end
    end
    
    function SpawnTrail(FROM,TO,BIG)
        local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "New Yeller", "Trail", VT(0,0,0))
        MakeForm(TRAIL,"Cyl")
        local DIST = (FROM - TO).Magnitude
        if BIG == true then
            TRAIL.Size = VT(0.5,DIST,0.5)
        else
            TRAIL.Size = VT(0.25,DIST,0.25)
        end
        TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
        coroutine.resume(coroutine.create(function()
            for i = 1, 5 do
                Swait()
                TRAIL.Transparency = TRAIL.Transparency + 0.1
            end
            TRAIL:remove()
        end))
    end
    
    function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
        local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
        local mesh = IT("SpecialMesh",wave)
        mesh.MeshType = "Sphere"
        mesh.Scale = SIZE
        mesh.Offset = VT(0,0,0)
        wave.CFrame = CFRAME
        coroutine.resume(coroutine.create(function(PART)
            for i = 1, WAIT do
                Swait()
                mesh.Scale = mesh.Scale + GROW
                wave.Transparency = wave.Transparency + (1/WAIT)
                if wave.Transparency > 0.99 then
                    wave:remove()
                end
            end
        end))
    end
    
    function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
        local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
        local mesh = IT("SpecialMesh",wave)
        mesh.MeshType = "Sphere"
        mesh.Scale = SIZE
        mesh.Offset = VT(0,0,0)
        wave.CFrame = CFRAME
        coroutine.resume(coroutine.create(function(PART)
            for i = 1, WAIT do
                Swait()
                mesh.Scale = mesh.Scale + GROW
                wave.Transparency = wave.Transparency + (1/WAIT)
                if wave.Transparency > 0.99 then
                    wave:remove()
                end
            end
        end))
    end
    
    function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
        local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
        local mesh = IT("BlockMesh",wave)
        wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
        coroutine.resume(coroutine.create(function(PART)
            for i = 1, WAIT do
                Swait()
                mesh.Scale = mesh.Scale + GROW
                wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
                wave.Transparency = wave.Transparency + (0.5/WAIT)
                if wave.Transparency > 0.99 then
                    wave:remove()
                end
            end
        end))
    end
    
    function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
        local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
        local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
        wave.CFrame = CFRAME
        coroutine.resume(coroutine.create(function(PART)
            for i = 1, WAIT do
                Swait()
                mesh.Scale = mesh.Scale + GROW
                if DOESROT == true then
                    wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
                end
                wave.Transparency = wave.Transparency + 0.5 / WAIT
                if wave.Transparency > 0.99 then
                    wave:remove()
                end
            end
        end))
    end
    
    local DECAL = IT("Decal")
    function MagicRing()
        local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
        local MESH = IT("BlockMesh",RING)
        local BOTTOMTEXTURE = DECAL:Clone()
        BOTTOMTEXTURE.Parent = RING
        BOTTOMTEXTURE.Face = "Bottom"
        BOTTOMTEXTURE.Name = "BottomTexture"
        local TOPTEXTURE = DECAL:Clone()
        TOPTEXTURE.Parent = RING
        TOPTEXTURE.Face = "Top"
        TOPTEXTURE.Name = "TopTexture"
        BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
        TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
        BOTTOMTEXTURE.Color3 = C3(0,0,0)
        TOPTEXTURE.Color3 = C3(1,1,1)
        return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
    end
    
    Debris = game:GetService("Debris")
    
    function CastProperRay(StartPos, EndPos, Distance, Ignore)
        local DIRECTION = CF(StartPos,EndPos).lookVector
        return Raycast(StartPos, DIRECTION, Distance, Ignore)
    end
    
    function turnto(position)
        RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
    end
    
    function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
        local CHILDREN = workspace:GetDescendants()
        for index, CHILD in pairs(CHILDREN) do
            if CHILD.ClassName == "Model" then
                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                if HUM then
                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                    if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
                        local CAMSHAKER = script.CamShake:Clone()
                        CAMSHAKER.Shake.Value = INTENSITY
                        CAMSHAKER.Timer.Value = TIME
                        CAMSHAKER.Parent = CHILD
                        CAMSHAKER.Disabled = false
                    end
                end
            end
        end
    end
    
    --//=================================\\
    --||	     WEAPON CREATION
    --\\=================================//
    
    --usedmostly on shackluster edits and shit
    ---------------------------------Weapon/armor creation------------------------
    
    function WWeld(a, b, acf)
        local we = Instance.new("Weld", a)
        we.Part0 = a
        we.Part1 = b
    if acf ~= nil then
        we.C0 = acf
    end
    end
    
    for i = 1,10 do
    wait()
    end
    
    TORSO = script.Torso
    
    TORSO.Parent = Character
    
    WWeld(TORSO.Torso,Torso, CF(0, 0, 0)*ANGLES(RAD(176),RAD(359),RAD(180)), CF(0, 0, 0))
    
    
    
    -------------------------------------------------------------------------------------------
    --- outfit
    
    
    
    
    local Tec9 = script.Tec9:Clone()
    Tec9.Parent = RightArm
    for i, v in pairs(Tec9:GetChildren()) do
        v.Transparency = 1
    end
    CreateWeld(Tec9.Handle,RightArm,Tec9.Handle,-0.3,-0.2,-0.9,math.rad(90),math.rad(0),math.rad(180),0,0,0,math.rad(0),math.rad(0),math.rad(0))
    local Hole = Tec9.Hole
    
    
    game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
    local function align(part0, part1)
        attachment = Instance.new("Attachment", part0)
        attachment.Position = Vector3.new(1, -0.5, -0.3) -- positioning
        attachment.Orientation = Vector3.new(90, 90, 0) -- orienation/rotation
        
        attachment02 = Instance.new("Attachment", part1) -- arm or part
        
        lol = Instance.new("AlignPosition", part0)
        lol.Attachment0 = attachment
        lol.Attachment1 = attachment02
        lol.MaxForce = math.huge
        lol.RigidityEnabled = true -- makes it not wobbly
        
        pog = Instance.new("AlignOrientation", part0)
        pog.Attachment0 = attachment
        pog.Attachment1 = attachment02
        pog.Responsiveness = 20
        pog.RigidityEnabled = true-- makes it not wobbly
    end
    align(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, game.Players.LocalPlayer.Character["Right Arm"])
    
    
    local Particle = IT("ParticleEmitter",nil)
    Particle.Enabled = false
    Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
    Particle.LightEmission = 0.5
    Particle.Rate = 150
    Particle.ZOffset = 0.2
    Particle.Rotation = NumberRange.new(-180, 180)
    Particle.RotSpeed = NumberRange.new(-180, 180)
    Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
    Particle.Color = ColorSequence.new(C3(1,1,1),C3(0,0,0))
    
    --ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
    function ParticleEmitter(Table)
        local PRTCL = Particle:Clone()
        local Speed = Table.Speed or 5
        local Drag = Table.Drag or 0
        local Size1 = Table.Size1 or 1
        local Size2 = Table.Size2 or 5
        local Lifetime1 = Table.Lifetime1 or 1
        local Lifetime2 = Table.Lifetime2 or 1.5
        local Parent = Table.Parent or Torso
        local Emit = Table.Emit or 100
        local Offset = Table.Offset or 360
        local Acel = Table.Acel or VT(0,0,0)
        local Enabled = Table.Enabled or false
        PRTCL.Parent = Parent
        PRTCL.Size = NumberSequence.new(Size1,Size2)
        PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
        PRTCL.Speed = NumberRange.new(Speed)
        PRTCL.VelocitySpread = Offset
        PRTCL.Drag = Drag
        PRTCL.Acceleration = Acel
        if Enabled == false then
            PRTCL:Emit(Emit)
            Debris:AddItem(PRTCL,Lifetime2)
        else
            PRTCL.Enabled = true
        end
        return PRTCL
    end
    
    --ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
    
    for _, c in pairs(CharacterA:GetChildren()) do
        if c.ClassName == "Part" then
            c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        end
    end
    
    CharacterA.Parent = Character
    
    Characterb.Parent = Character
    
    
    local SKILLTEXTCOLOR = C3(1,1,1)
    local SKILLFONT = ""
    local SKILLTEXTSIZE = 7
    
    local BODY = {}
    for _, c in pairs(Character:GetDescendants()) do
        if c:IsA("BasePart") and c.Name ~= "Handle" then
            if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
                c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            end
            table.insert(BODY, {
                c,
                c.Parent,
                c.Material,
                c.Color,
                c.Transparency,
                c.Size,
                c.Name
            })
        elseif c:IsA("JointInstance") or c:IsA("Shirt") or c:IsA("Pants") then
            table.insert(BODY, {
                c,
                c.Parent,
                nil,
                nil,
                nil,
                nil,
                nil
            })
        end
    end
    function refit()
        Character.Parent = workspace
        Effects.Parent = Character
        for e = 1, #BODY do
            if BODY[e] ~= nil then
                local STUFF = BODY[e]
                local PART = STUFF[1]
                local PARENT = STUFF[2]
                local MATERIAL = STUFF[3]
                local COLOR = STUFF[4]
                local TRANSPARENCY = STUFF[5]
                local NAME = STUFF[7]
                if PART.ClassName == "Part" and PART ~= RootPart then
                    PART.Material = MATERIAL
                    PART.Transparency = TRANSPARENCY
                    PART.Name = NAME
                end
                if PART.Parent ~= PARENT then
                    if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
                        Humanoid:remove()
                    end
                    PART.Parent = PARENT
                    if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
                        Humanoid = IT("Humanoid", Character)
                    end
                end
            end
        end
    end
    
    --[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
    local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
    local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
    local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
    local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
    ]]
    --[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
    local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
    local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
    local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
    local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
    ]]
    
    function chatfunc(text)
        local chat = coroutine.wrap(function()
        if Character:FindFirstChild("TalkingBillBoard")~= nil then
            Character:FindFirstChild("TalkingBillBoard"):destroy()
        end
        local Bill = Instance.new("BillboardGui",Character)
        Bill.Size = UDim2.new(0,100,0,40)
        Bill.StudsOffset = Vector3.new(0,3,0)
        Bill.Adornee = Character.Head
        Bill.Name = "TalkingBillBoard"
        local Hehe = Instance.new("TextLabel",Bill)
        Hehe.BackgroundTransparency = 1
        Hehe.BorderSizePixel = 0
        Hehe.Text = ""
        Hehe.Font = "SourceSansItalic"
        Hehe.TextSize = 40
        Hehe.TextStrokeTransparency = 0
        Hehe.Size = UDim2.new(1,0,0.5,0)
        coroutine.resume(coroutine.create(function()
            while Hehe ~= nil do
                Swait()	
                Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
                Hehe.Rotation = math.random(-5,5)
                Hehe.TextColor3 = Color3.new(0,0,0)
                Hehe.TextStrokeColor3 = Color3.new(1,1,1)
            end
        end))
        for i = 1,string.len(text),1 do
            Swait()
            Hehe.Text = string.sub(text,1,i)
        end
        Swait(90)--Re[math.random(1, 93)]
        for i = 0, 1, .025 do
            Swait()
            Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
            Hehe.TextStrokeTransparency = i
            Hehe.TextTransparency = i
        end
        Bill:Destroy()
        end)
    chat()
    end
    
    function onChatted(msg)
        chatfunc(msg)
    end
    
    Player.Chatted:connect(onChatted)
    
    function printbye(Name)
        local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
        chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
    end
    
    workspace.ChildAdded:connect(function(instance)
        for BANISH = 1, #TOBANISH do
            if TOBANISH[BANISH] ~= nil then
                if instance.Name == TOBANISH[BANISH] then
                    coroutine.resume(coroutine.create(function()
                        printbye(instance.Name)
                        instance:ClearAllChildren()
                        Debris:AddItem(instance,0.0005)
                    end))
                end
            end
        end
    end)
    
    --//=================================\\
    --||			DAMAGING
    --\\=================================//
    
    function Banish(Foe)
        if Foe then
            coroutine.resume(coroutine.create(function()
                --if game.Players:FindFirstChild(Foe.Name) then
                    table.insert(TOBANISH,Foe.Name)
                    printbye(Foe.Name)
                --end
                Foe.Archivable = true
                local CLONE = Foe:Clone()
                Foe:Destroy()
                CLONE.Parent = Effects
                CLONE:BreakJoints()
                local MATERIALS = {"Glass","Neon"}
                for _, c in pairs(CLONE:GetDescendants()) do
                    if c:IsA("BasePart") then
                        if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
                             CreateSound(340722848, c, 10, 1, false)
                        end
                        c.Anchored = true
                        c.Transparency = c.Transparency + 0.2
                        c.Material = MATERIALS[MRANDOM(1,2)]
                        c.Color = C3(1,1,1)
                        if c.ClassName == "MeshPart" then
                            c.TextureID = ""
                        end
                        if c:FindFirstChildOfClass("SpecialMesh") then
                            c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
                        end
                        if c:FindFirstChildOfClass("Decal") then
                            c:FindFirstChildOfClass("Decal"):remove()
                        end
                        c.Name = "Banished"
                        c.CanCollide = false
                    else
                        c:remove()
                    end
                end
                local A = false
                for i = 1, 35 do
                    if A == false then
                        A = true
                    elseif A == true then
                        A = false
                    end
                    for _, c in pairs(CLONE:GetDescendants()) do
                        if c:IsA("BasePart") then
                            c.Anchored = true
                            c.Material = MATERIALS[MRANDOM(1,2)]
                            c.Transparency = c.Transparency + 0.8/35
                            if A == false then
                                c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
                            elseif A == true then
                                c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
                            end
                        end
                    end
                    Swait()
                end
                CLONE:remove()
            end))
        end
    end
    
    function ApplyAoE(POSITION,RANGE,ISBANISH)
    return
    end
    
    
    function ManualDamage(Humanoid,Damage,TorsoPart)
    return
    end
    
    local asd = Instance.new("ParticleEmitter")
    asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
    asd.LightEmission = .1
    asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
    aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
    bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
    asd.Transparency = bbb
    asd.Size = aaa
    asd.ZOffset = .9
    asd.Acceleration = Vector3.new(0, -15, 0)
    asd.LockedToPart = false
    asd.EmissionDirection = "Back"
    asd.Lifetime = NumberRange.new(1, 2)
    asd.Rotation = NumberRange.new(-100, 100)
    asd.RotSpeed = NumberRange.new(-100, 100)
    asd.Speed = NumberRange.new(10)
    asd.Enabled = false
    asd.VelocitySpread = 999
    
    function getbloody(victim,amount)
        local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
        PART.CFrame = victim.CFrame
        local HITPLAYERSOUNDS = {"356551938","264486467"}
        Debris:AddItem(PART,5)
        CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
        CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
        CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
        local prtcl = asd:Clone()
        prtcl.Parent = PART
        prtcl:Emit(amount*10)
    end
    
    function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
        local CHILDREN = workspace:GetDescendants()
        for index, CHILD in pairs(CHILDREN) do
            if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                if HUM then
                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                    if TORSO then
                        if (TORSO.Position - POSITION).Magnitude <= RANGE then
                            if INSTAKILL == true then
                                CHILD:BreakJoints()
                            else
                                local DMG = MRANDOM(MINDMG,MAXDMG)
                                ManualDamage(HUM,DMG,TORSO)
                            end
                            if FLING > 0 then
                                for _, c in pairs(CHILD:GetChildren()) do
                                    if c:IsA("BasePart") then
                                        local bv = Instance.new("BodyVelocity") 
                                        bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
                                        bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
                                        bv.Parent = c
                                        Debris:AddItem(bv,0.05)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    function Dismember(MAN,DOWHAT)
        for index, CHILD in pairs(MAN:GetDescendants()) do
            if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
                CHILD:Destroy()
            end
        end
        if DOWHAT == "Ragdoll" then
            local HUM = MAN:FindFirstChildOfClass("Humanoid")
            if HUM then
                HUM.Health = 0
            end
            if MAN:FindFirstChild("UpperTorso") then
                local SCRIPT = script.R15Ragdoll:Clone()
                SCRIPT.Parent = MAN
                SCRIPT.Disabled = false
            else
                local SCRIPT = script.R6Ragdoll:Clone()
                SCRIPT.Parent = MAN
                SCRIPT.Disabled = false
            end
            MAN:BreakJoints()
        else
            local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
            local HED = MAN:FindFirstChild("Head")
            if TORSO and HED then
                if DOWHAT == "Head" then
                    if TORSO:FindFirstChild("TorsoA4") then
                        TORSO:FindFirstChild("TorsoA4"):Remove()
                    elseif MAN:FindFirstChild("RagdollConstraintHead") then
                        MAN:FindFirstChild("RagdollConstraintHead"):Remove()
                    end
                    HED:BreakJoints()
                elseif DOWHAT == "RightArm" then
                    if TORSO:FindFirstChild("TorsoA3") then
                        TORSO:FindFirstChild("TorsoA3"):Remove()
                    elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
                        MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
                    end
                elseif DOWHAT == "LeftArm" then
                    if TORSO:FindFirstChild("TorsoA2") then
                        TORSO:FindFirstChild("TorsoA2")
                    elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
                        MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
                    end
                elseif DOWHAT == "Legs" then
                    if TORSO.Name == "Torso" then
                        if TORSO:FindFirstChild("TorsoA") then
                            TORSO:FindFirstChild("TorsoA"):Remove()
                        end
                        if TORSO:FindFirstChild("TorsoA1") then
                            TORSO:FindFirstChild("TorsoA1"):Remove()
                        end
                    elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
                        MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
                    end
                end
            end
        end
    end
    
    function AttachmentCFrame(A)
        return A.Parent.CFrame*CF(A.Position)
    end
    
    function R15Ragdoll(character,KeepArms)
        character:BreakJoints()
        coroutine.resume(coroutine.create(function()
            recurse(character, function(_,v)
                if v:IsA("Attachment") then
                    v.Axis = Vector3.new(0, 1, 0)
                    v.SecondaryAxis = Vector3.new(0, 0, 1)
                    v.Rotation = Vector3.new(0, 0, 0)
                end
            end)
            for _,child in next,character:GetChildren() do
                if child:IsA("Accoutrement") then
                    for _,part in next,child:GetChildren() do
                        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                            local attachment1 = part:FindFirstChildOfClass("Attachment")
                            local attachment0 = getAttachment0(character,attachment1.Name)
                            if attachment0 and attachment1 then
                                local constraint = Instance.new("HingeConstraint")
                                constraint.Attachment0 = attachment0
                                constraint.Attachment1 = attachment1
                                constraint.LimitsEnabled = true
                                constraint.UpperAngle = 0
                                constraint.LowerAngle = 0
                                constraint.Parent = character
                            end
                            ArtificialHitbox(part)
                        elseif part.Name == "HumanoidRootPart" then
                            part:remove()
                        end
                    end
                end
            end
            
            ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
                {"LimitsEnabled",true};
                {"UpperAngle",5};
            })
            if character:FindFirstChild("Head") then
                ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
                    {"LimitsEnabled",true};
                    {"UpperAngle",15};
                })
            end
            
            local handProperties = {
                {"LimitsEnabled", true};
                {"UpperAngle",0};
                {"LowerAngle",0};
            }
            ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
            ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
            
            local shinProperties = {
                {"LimitsEnabled", true};
                {"UpperAngle", 0};
                {"LowerAngle", -75};
            }
            ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
            ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
            
            local footProperties = {
                {"LimitsEnabled", true};
                {"UpperAngle", 15};
                {"LowerAngle", -45};
            }
            ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
            ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
            if KeepArms == true then
                ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
                ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
                ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
                ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
            end
            ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
            ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
            Debris:AddItem(character,5)
        end))
    end
    
    function Ragdoll(Character2,CharTorso,KeepArms)
        coroutine.resume(coroutine.create(function()
            Character2:BreakJoints()
            local hum = Character2:findFirstChild("Humanoid")
            hum:remove()
            local function Scan(ch)
                local e
                for e = 1,#ch do
                    Scan(ch[e]:GetChildren())
                    if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
                        ch[e]:remove()
                    end
                end
            end
            local NEWHUM = IT("Humanoid")
            NEWHUM.Name = "Corpse"
            NEWHUM.Health = 0
            NEWHUM.MaxHealth = 0
            NEWHUM.PlatformStand = true
            NEWHUM.Parent = Character2
            NEWHUM.DisplayDistanceType = "None"
        
            local ch = Character2:GetChildren()
            local i
            for i = 1,#ch do
                if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
                    ch[i]:remove()
                end
            end
        
            local Torso2 = Character2.Torso
            local movevector = Vector3.new()
        
            if Torso2 then
                movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
                local Head = Character2:FindFirstChild("Head")
                if Head then
                    local Neck = Instance.new("Weld")
                    Neck.Name = "Neck"
                    Neck.Part0 = Torso2
                    Neck.Part1 = Head
                    Neck.C0 = CFrame.new(0, 1.5, 0)
                    Neck.C1 = CFrame.new()
                    Neck.Parent = Torso2
        
                end
                local Limb = Character2:FindFirstChild("Right Arm")
                if Limb and KeepArms == true then
        
                    Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
                    local Joint = Instance.new("Glue")
                    Joint.Name = "RightShoulder"
                    Joint.Part0 = Torso2
                    Joint.Part1 = Limb
                    Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                    Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                    Joint.Parent = Torso2
        
                    local B = Instance.new("Part")
                    B.TopSurface = 0
                    B.BottomSurface = 0
                    B.formFactor = "Symmetric"
                    B.Size = Vector3.new(1, 1, 1)
                    B.Transparency = 1
                    B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                    B.Parent = Character2
                    local W = Instance.new("Weld")
                    W.Part0 = Limb
                    W.Part1 = B
                    W.C0 = CFrame.new(0, -0.5, 0)
                    W.Parent = Limb
        
                end
                local Limb = Character2:FindFirstChild("Left Arm")
                if Limb and KeepArms == true then
        
                    Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
                    local Joint = Instance.new("Glue")
                    Joint.Name = "LeftShoulder"
                    Joint.Part0 = Torso2
                    Joint.Part1 = Limb
                    Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                    Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                    Joint.Parent = Torso2
        
                    local B = Instance.new("Part")
                    B.TopSurface = 0
                    B.BottomSurface = 0
                    B.formFactor = "Symmetric"
                    B.Size = Vector3.new(1, 1, 1)
                    B.Transparency = 1
                    B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                    B.Parent = Character2
                    local W = Instance.new("Weld")
                    W.Part0 = Limb
                    W.Part1 = B
                    W.C0 = CFrame.new(0, -0.5, 0)
                    W.Parent = Limb
        
                end
                local Limb = Character2:FindFirstChild("Right Leg")
                if Limb then
        
                    Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
                    local Joint = Instance.new("Glue")
                    Joint.Name = "RightHip"
                    Joint.Part0 = Torso2
                    Joint.Part1 = Limb
                    Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                    Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                    Joint.Parent = Torso2
        
                    local B = Instance.new("Part")
                    B.TopSurface = 0
                    B.BottomSurface = 0
                    B.formFactor = "Symmetric"
                    B.Size = Vector3.new(1, 1, 1)
                    B.Transparency = 1
                    B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                    B.Parent = Character2
                    local W = Instance.new("Weld")
                    W.Part0 = Limb
                    W.Part1 = B
                    W.C0 = CFrame.new(0, -0.5, 0)
                    W.Parent = Limb
        
                end
                local Limb = Character2:FindFirstChild("Left Leg")
                if Limb then
        
                    Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
                    local Joint = Instance.new("Glue")
                    Joint.Name = "LeftHip"
                    Joint.Part0 = Torso2
                    Joint.Part1 = Limb
                    Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                    Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                    Joint.Parent = Torso2
        
                    local B = Instance.new("Part")
                    B.TopSurface = 0
                    B.BottomSurface = 0
                    B.formFactor = "Symmetric"
                    B.Size = Vector3.new(1, 1, 1)
                    B.Transparency = 1
                    B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                    B.Parent = Character2
                    local W = Instance.new("Weld")
                    W.Part0 = Limb
                    W.Part1 = B
                    W.C0 = CFrame.new(0, -0.5, 0)
                    W.Parent = Limb
        
                end
                --[
                local Bar = Instance.new("Part")
                Bar.TopSurface = 0
                Bar.BottomSurface = 0
                Bar.formFactor = "Symmetric"
                Bar.Size = Vector3.new(1, 1, 1)
                Bar.Transparency = 1
                Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
                Bar.Parent = Character2
                local Weld = Instance.new("Weld")
                Weld.Part0 = Torso2
                Weld.Part1 = Bar
                Weld.C0 = CFrame.new(0, 0.5, 0)
                Weld.Parent = Torso2
                --]]
            end
            Character2.Parent = workspace
            Debris:AddItem(Character2,5)
        
            return Character2,Torso2
        end))
    end
    
    function KickThatNigga(CHARACTER)
        g = game.Players:GetPlayers()
        local kickfolder = IT("Folder",Effects)
        local naeeym2 = Instance.new("BillboardGui",kickfolder)
        naeeym2.AlwaysOnTop = false
        naeeym2.Size = UDim2.new(5,35,2,35)
        naeeym2.StudsOffset = Vector3.new(0,1,0)
        naeeym2.Name = "Mark"
        local tecks2 = Instance.new("TextLabel",naeeym2)
        tecks2.BackgroundTransparency = 1
        tecks2.TextScaled = true
        tecks2.BorderSizePixel = 0
        tecks2.Text = ""
        tecks2.Font = "SciFi"
        tecks2.TextSize = 30
        tecks2.TextStrokeTransparency = 1
        tecks2.TextColor3 = Color3.new(1,0,0)
        tecks2.TextStrokeColor3 = Color3.new(1,0,0)
        tecks2.Size = UDim2.new(1,0,0.5,0)
        tecks2.Parent = naeeym2
         CreateSound("527749592", CHARACTER, 600, 1, false)
        for i,v in ipairs(CHARACTER:GetChildren()) do
            if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                if v.Name ~= "HumanoidRootPart" then
                    local BOD = v:Clone()
                    BOD.CanCollide = false
                    BOD.Anchored = true
                    BOD.CFrame = v.CFrame
                    BOD.Parent = kickfolder
                    BOD.Material = "Granite"
                    BOD.Color = C3(.3,0,0)
                    if BOD:FindFirstChildOfClass("Decal") then
                        BOD:FindFirstChildOfClass("Decal"):remove()
                    end
                    if BOD.Name == "Head" then
                        naeeym2.Adornee = BOD
                    end
                    if BOD.ClassName == "MeshPart" then
                        BOD.TextureID = ""
                    end
                end
            end
        end
    
        if CHARACTER ~= Character then
        CHARACTER:remove()
        end
        if CHARACTER.Name == "Helkern" then
            Character:BreakJoints()
        end
        coroutine.resume(coroutine.create(function()
            for i = 1, 50 do
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 1
                    end
                    naeeym2.Enabled = false
                end
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 0
                    end
                    naeeym2.Enabled = true
                end
            end
            kickfolder:remove()
        end))
    end
    
    function ApplyAoE(POSITION,RANGE,ISKICKED)
        local CHILDREN = workspace:GetDescendants()
        for index, CHILD in pairs(CHILDREN) do
            if CHILD.ClassName == "Model" and CHILD ~= Character then
                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                if HUM then
                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                    if TORSO then
                        if (TORSO.Position - POSITION).Magnitude <= RANGE then
                            if ISKICKED == true then
                                KickThatNigga(CHILD)
                            else
                                if ISKICKED == "Gravity" then
                                    HUM.PlatformStand = true
                                    if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                                        local grav = Instance.new("BodyPosition",TORSO)
                                        grav.D = 15
                                        grav.P = 20000
                                        grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
                                        grav.position = TORSO.Position
                                        grav.Name = "V3BanishForce"..Player.Name
                                    else
                                        TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
                                        TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
                                    end
                                else
                                    HUM.PlatformStand = false
                                end
                            end
                        elseif ISKICKED == "Gravity" then
                            if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                                TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
                                HUM.PlatformStand = false
                            end
                        end
                    end
                end
            end
        end
    end
    
    local BEANED = {}
    
    function Ban(bitch)	
    if bitch then	
    g = game.Players:GetPlayers()
        local kickfolder = IT("Folder",Effects)
        local naeeym2 = Instance.new("BillboardGui",kickfolder)
        naeeym2.AlwaysOnTop = false
        naeeym2.Size = UDim2.new(5,35,2,35)
        naeeym2.StudsOffset = Vector3.new(0,1,0)
        naeeym2.Name = "Mark"
        local tecks2 = Instance.new("TextLabel",naeeym2)
        tecks2.BackgroundTransparency = 1
        tecks2.TextScaled = true
        tecks2.BorderSizePixel = 0
        tecks2.Text = ""
        tecks2.Font = "SciFi"
        tecks2.TextSize = 30
        tecks2.TextStrokeTransparency = 0
        tecks2.TextColor3 = Color3.new(1,0,0)
        tecks2.TextStrokeColor3 = Color3.new(1,0,0)
        tecks2.Size = UDim2.new(1,0,0.5,0)
        tecks2.Parent = naeeym2
    -- CreateSound("2570187601", bitch, 600, 1, false)
    local Players = game:GetService("Players")
    local fag = Players:FindFirstChild(bitch.Name)
    --faggut:Kick()
        if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
        end
            if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
            end
                if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                end
                    if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                    end
                        if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                        end
                            if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                            end
                                                    if Players:FindFirstChild("Drago_TH") then
                            end
                            table.insert(BEANED,bitch.name)
        --]]
                --CreateSound("527749592", game.Workspace, 700, 1, false)
        --CHARACTER:Remove()
        --[[
        for i,v in pairs(g) do
        --v:remove()
        end ]]--
        --[[
        if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
    for i,v in pairs(g) do
        if string.find(string.upper(v.Name),CHARACTER) == 1 then
    v:remove()
    end
    end
        end]]--
        --[[
            for _, p in pairs(game.Players:GetChildren()) do
            if p:FindFirstChild("CHARACTER") then
    
            end
        end]]--
        coroutine.resume(coroutine.create(function()
            for i = 1, 50 do
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 1
                    end
                    naeeym2.Enabled = false
                end
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 0
                    end
                    naeeym2.Enabled = true
                end
            end
            kickfolder:remove()
        end))
        --wait(6)
        --bitch:Remove()
    end
    end
    
    local function CheckForBan(player)
        for i = 1, #BEANED do
            if player.Name == BEANED[i] then
                player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
            end
        end
    end
    
    
    game.Players.PlayerAdded:connect(function()
        for i,v in pairs(game.Players:GetPlayers())do
            CheckForBan(v)
        end  
    end)
    
    
    function Kick(bitch)
    g = game.Players:GetPlayers()
        local kickfolder = IT("Folder",Effects)
        local naeeym2 = Instance.new("BillboardGui",kickfolder)
        naeeym2.AlwaysOnTop = false
        naeeym2.Size = UDim2.new(5,35,2,35)
        naeeym2.StudsOffset = Vector3.new(0,1,0)
        naeeym2.Name = "Mark"
        local tecks2 = Instance.new("TextLabel",naeeym2)
        tecks2.BackgroundTransparency = 1
        tecks2.TextScaled = true
        tecks2.BorderSizePixel = 0
        tecks2.Text = ""
        tecks2.Font = "SciFi"
        tecks2.TextSize = 30
        tecks2.TextStrokeTransparency = 0
        tecks2.TextColor3 = Color3.new(1,0,0)
        tecks2.TextStrokeColor3 = Color3.new(1,0,0)
        tecks2.Size = UDim2.new(1,0,0.5,0)
        tecks2.Parent = naeeym2
    -- CreateSound("2570187601", bitch, 600, 1, false)
    local Players = game:GetService("Players")
    local fag = Players:FindFirstChild(bitch.Name)
    --faggut:Kick()
        if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
        end
            if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
            end
                if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                end
                    if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                    end
                        if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
                        end
                            if Players:FindFirstChild(bitch.Name) then
        fag:Kick(reason)
        end
        --[[
            for i,v in pairs(fag.Name) do
            if (v:lower() == newPlayer.Name:lower()) then
                newPlayer:Remove()
            end
        end]]--
                --CreateSound("527749592", game.Workspace, 700, 1, false)
        --CHARACTER:Remove()
        --[[
        for i,v in pairs(g) do
        --v:remove()
        end ]]--
        --[[
        if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
    for i,v in pairs(g) do
        if string.find(string.upper(v.Name),CHARACTER) == 1 then
    v:remove()
    end
    end
        end]]--
        --[[
            for _, p in pairs(game.Players:GetChildren()) do
            if p:FindFirstChild("CHARACTER") then
    
            end
        end]]--
        coroutine.resume(coroutine.create(function()
            for i = 1, 50 do
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 1
                    end
                    naeeym2.Enabled = false
                end
                Swait()
                for i,v in ipairs(kickfolder:GetChildren()) do
                    if v.ClassName == "Part" or v.ClassName == "MeshPart" then
                        v.Transparency = 0
                    end
                    naeeym2.Enabled = true
                end
            end
            kickfolder:remove()
        end))
        --wait(6)
        --bitch:Remove()
    end
    
    
    function ApplyAoE(POSITION,RANGE,ISBANISH)
        local CHILDREN = workspace:GetDescendants()
        for index, CHILD in pairs(CHILDREN) do
            if CHILD.ClassName == "Model" and CHILD ~= Character then
                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                if HUM then
                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                    if TORSO then
                        if (TORSO.Position - POSITION).Magnitude <= RANGE then
                            if ISBANISH == true then
                                Banish(CHILD)
                            else
                                if ISBANISH == "Gravity" then
                                    HUM.PlatformStand = true
                                    if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                                        local grav = Instance.new("BodyPosition",TORSO)
                                        grav.D = 15
                                        grav.P = 20000
                                        grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
                                        grav.position = TORSO.Position
                                        grav.Name = "V3BanishForce"..Player.Name
                                    else
                                        TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
                                        TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
                                    end
                                else
                                    HUM.PlatformStand = false
                                end
                            end
                        elseif ISBANISH == "Gravity" then
                            if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                                TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
                                HUM.PlatformStand = false
                            end
                        end
                    end
                end
            end
        end
    end
    
    function KickAoE(POSITION,RANGE,BRUTAL)
        local CHILDREN = workspace:GetDescendants()
        for index, CHILD in pairs(CHILDREN) do
            if CHILD.ClassName == "Model" and CHILD ~= Character then
                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                if HUM then
                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                    if TORSO then
                        if (TORSO.Position - POSITION).Magnitude <= RANGE then
                            if BRUTAL == true then
        if Type == "Banish" then
                                KickThatNigger(CHILD)
        elseif Type == "Ban" then
            Ban(CHILD)
        elseif Type == "Kick" then
            Kick(CHILD)
                --elseif Type == "Tangle" then
            --Entangle(CHILD)
            end
                            else
                                CHILD:BreakJoints()
                            end
                        end
                    end
                end
            end
        end
    end
    
    local PE=Instance.new("ParticleEmitter",art)
    PE.LightEmission=.8
    PE.Color = ColorSequence.new(BRICKC("Really red").Color)
    PE.Lifetime=NumberRange.new(0.35,1.5)
    PE.Rotation=NumberRange.new(0,360)
    PE.Rate=999
    PE.VelocitySpread = 10000
    PE.Acceleration = Vector3.new(0,0,0)
    PE.Drag = 5
    PE.Speed = NumberRange.new(0,0,0)
    PE.Texture="http://www.roblox.com/asset/?id=833874434"
    PE.ZOffset = -1.5
    PE.Name = "PE"
    PE.Enabled = false
    
    function particles(art)
        local PARTICLES = PE:Clone()
        PARTICLES.Parent = art
    end
    
    function KillChildren(v)
        v:BreakJoints()
        for _, c in pairs(v:GetChildren()) do
            if c.ClassName == "Part" or c.ClassName == "MesPart" then
                if c.Transparency < 1 then
                    if c:FindFirstChildOfClass("Decal") then
                        c:FindFirstChildOfClass("Decal"):remove()
                    end
                    particles(c)
                    c.PE.Enabled = true
                    c.Parent = Effects
                    c.CanCollide = false
                    c.Material = "Neon"
                    c.Color = C3(1,0,0)
                    c.Transparency = 0.5
                    local grav = Instance.new("BodyPosition",c)
                    grav.P = 20000
                    grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
                    grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
                    grav.Name = "GravityForce"
                    coroutine.resume(coroutine.create(function()
                    for i = 1, 50 do
                        Swait()
                        c.Transparency = c.Transparency + 0.01
                    end
                    c.PE.Enabled = false
                    Debris:AddItem(c,2)
                    end))
                end
            end
        end
    end
    
    function killnearest(position,range)
        for i,v in ipairs(workspace:GetChildren()) do
        local body = v:GetChildren()
            for part = 1, #body do
                if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
                    if(body[part].Position - position).Magnitude < range then
                        if v.ClassName == "Model" then
                            KillChildren(v)
                        end
                    end
                end
            end
        end
    end
    
    function Dismember(MAN,DOWHAT)
        for index, CHILD in pairs(MAN:GetDescendants()) do
            if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
                CHILD:Destroy()
            end
        end
        if DOWHAT == "Ragdoll" then
            local HUM = MAN:FindFirstChildOfClass("Humanoid")
            if HUM then
                HUM.Health = 0
            end
            if MAN:FindFirstChild("UpperTorso") then
                local SCRIPT = script.R15Ragdoll:Clone()
                SCRIPT.Parent = MAN
                SCRIPT.Disabled = false
            else
                local SCRIPT = script.R6Ragdoll:Clone()
                SCRIPT.Parent = MAN
                SCRIPT.Disabled = false
            end
            MAN:BreakJoints()
        else
            local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
            local HED = MAN:FindFirstChild("Head")
            if TORSO and HED then
                if DOWHAT == "Head" then
                    if TORSO:FindFirstChild("TorsoA4") then
                        TORSO:FindFirstChild("TorsoA4"):Remove()
                    elseif MAN:FindFirstChild("RagdollConstraintHead") then
                        MAN:FindFirstChild("RagdollConstraintHead"):Remove()
                    end
                    HED:BreakJoints()
                elseif DOWHAT == "RightArm" then
                    if TORSO:FindFirstChild("TorsoA3") then
                        TORSO:FindFirstChild("TorsoA3"):Remove()
                    elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
                        MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
                    end
                elseif DOWHAT == "LeftArm" then
                    if TORSO:FindFirstChild("TorsoA2") then
                        TORSO:FindFirstChild("TorsoA2")
                    elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
                        MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
                    end
                elseif DOWHAT == "Legs" then
                    if TORSO.Name == "Torso" then
                        if TORSO:FindFirstChild("TorsoA") then
                            TORSO:FindFirstChild("TorsoA"):Remove()
                        end
                        if TORSO:FindFirstChild("TorsoA1") then
                            TORSO:FindFirstChild("TorsoA1"):Remove()
                        end
                    elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
                        MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
                    end
                end
            end
        end
    end
    
    function ManSlaughter(MAN)
    
    end
    
    function ApplyDamage2(Humanoid,Damage,OneShot)
    
    end
    
    function BulletDetection(FROM,TO,BRUTAL)
        local AIMHIT,AIMPOS,NORMAL = CastProperRay(FROM,TO,2000,Character)
        coroutine.resume(coroutine.create(function()
            if AIMHIT ~= nil then
                if AIMHIT.Parent ~= Character then
                    if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") or AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
                        if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") then
                            if BRUTAL == true then
                                ApplyDamage2(AIMHIT.Parent:FindFirstChildOfClass("Humanoid"),999,true)
                            else
                                getbloody(AIMHIT,3)
                                AIMHIT.Parent:BreakJoints()
                                if AIMHIT.Name == "Head" then
                                    AIMHIT.Name = "HEADSHOT"
                                    AIMHIT:remove()
                                end
                            end
                        else
                            if BRUTAL == true then
                                ApplyDamage2(AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid"),999,true)
                            else
                                AIMHIT.Parent.Parent:BreakJoints()
                            end
                        end
                    end
                end
            end
        end))
        SpawnTrail(FROM,AIMPOS)
        return AIMHIT,AIMPOS,NORMAL
    end
    
    --//=================================\\
    --||	ATTACK FUNCTIONS AND STUFF
    --\\=================================//
    
    function Bomb()
     local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
        if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
         local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
          local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
           if TORSO and HUM.Health > 0 then
                ATTACK = true
                Rooted = false
                local GYRO = IT("BodyGyro",RootPart)
                GYRO.D = 275
                GYRO.P = 20000
                GYRO.MaxTorque = VT(0,40000,0)
                local grav = Instance.new("BodyPosition",TORSO)
                grav.D = 1500
                grav.P = 20000
                grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
                grav.position = TORSO.Position+VT(0,0,0)
                CreateSound(429459101, TORSO, 0.5, 1, false)
        for i=0, 4, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,TORSO.Position)
            WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(MRANDOM(-15,15)), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
        end
            SHAKECAM(HITPOS, 15, 2, 130)
            CreateSound(884348443, TORSO, 5, 0.8, false)
            killnearest(TORSO.Position, 5, 5)
            for i=0, 1, 0.1 / Animation_Speed do
            Swait()
            WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(160), RAD(MRANDOM(-15,15)), RAD(-70)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            end
        GYRO:Remove()
        ATTACK = false
        Rooted = false
        end
        end
    end
    
    function Bomb2()
    local TARGET = Mouse.Target
       if TARGET ~= nil then
       if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
       local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
       local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
       if ROOT and HUM.Health > 0 then
       local FOE = Mouse.Target.Parent
       RootPart.CFrame = ROOT.CFrame*CF(0,0,4.2)
       ROOT.Anchored = true
       local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
    if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
    local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
    local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
    if TORSO and HUM.Health > 0 then
    ATTACK = true
    Rooted = true
    Rooted = true
        for i=0, 3, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(65)), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(65)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
        end
            local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
            local CHILDREN = workspace:GetDescendants()
            for index, CHILD in pairs(CHILDREN) do
                if CHILD.ClassName == "Model" and CHILD ~= Character then
                    local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                    if HUM then
                        local TORSO = CHILD:FindFirstChild("Head")
                        if TORSO then
                            if (TORSO.Position - RootPart.Position).Magnitude <= 7 then
                                getbloody(TORSO,5)
                                SHAKECAM(HITPOS, 15, 2, 130)
                                TORSO:remove()
                                if CHILD:FindFirstChild("Torso") then
                                    Ragdoll(CHILD,Torso,true)
                                elseif CHILD:FindFirstChild("UpperTorso") then
                                    R15Ragdoll(CHILD,true)
                                end
                            end
                        end
                    end
                end
            end
            CreateSound(887549720, TORSO, 5, 1, false)
            for i=0, 1, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-90)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(120)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            end
        ATTACK = false
        Rooted = false
        end
        end
    end
    end
    end
    end
    
    function Taunt()
        ATTACK = true
        Rooted = true
        CreateSound(967069404, Head, 10, 0.9, false)
        for i=0, 4, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 2)) * ANGLES(RAD(10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(COS(10 * SINE / 2)), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(COS(-10 * SINE / 2)), RAD(COS(-10 * SINE / 2)), RAD(-8)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
        end
        ATTACK = false
        Rooted = false
    end
    
    
    function Zone()
        ATTACK = true
        Rooted = true
            local GYRO = IT("BodyGyro",nil)
            GYRO.D = 175
            GYRO.P = 20000
            GYRO.MaxTorque = VT(0,40000,0)
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
              for i=0, 0.7, 0.1 / Animation_Speed do
            Swait()
                    GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
              for i=0, 0.7, 0.1 / Animation_Speed do
            Swait()
                    GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(30)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
            CreateSound(317130715, Hole, 7, 1.3, false)
            for i=0, 0.7, 0.1 / Animation_Speed do
            Swait()
                    GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end 
        repeat
        for i=0, 0.1, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
                local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
            BulletDetection(Hole.Position,Mouse.Hit.p,true)
            local HIT,POS = CastProperRay(AttachmentCFrame(Hole.Nuzzle).p,MOUSEPOS,1000,Character)
            local DISTANCE = (POS - AttachmentCFrame(Hole.Nuzzle).p).Magnitude
            WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(0.8,0.8,0.8), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = 745308042, SoundPitch = 2, SoundVolume = 0.8})
            WACKYEFFECT({Time = 8, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.1,0.1,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
             SHAKECAM(HITPOS, 3, 3, 3) 
        for i=0, 0.08, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.3) * ANGLES(RAD(100), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
          until KEYHOLD == false
            for i=0, 1, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
        GYRO:Remove()
        ATTACK = false
        Rooted = false
        end
    
    
    
    --//=================================\\
    --||	  ASSIGN THINGS TO KEYS
    --\\=================================//
    
    -------------------------------------
    
    Humanoid.Animator.Parent = nil
    
    -------------------------------------
    
    
    function MouseDown(Mouse)
        if ATTACK == false then
        end
    end
    
    
    function MouseUp(Mouse)
    HOLD = false
    end
    
    function KeyDown(Key)
        KEYHOLD = true
        if Key == "z" and ATTACK == false then
            Zone()
            end
    end
    
    function KeyUp(Key)
        KEYHOLD = false
    end
    
        Mouse.Button1Down:connect(function(NEWKEY)
            MouseDown(NEWKEY)
        end)
        Mouse.Button1Up:connect(function(NEWKEY)
            MouseUp(NEWKEY)
        end)
        Mouse.KeyDown:connect(function(NEWKEY)
            KeyDown(NEWKEY)
        end)
        Mouse.KeyUp:connect(function(NEWKEY)
            KeyUp(NEWKEY)
        end)
    
    --//=================================\\
    --\\=================================//
    
    
    function unanchor()
        if UNANCHOR == true then
            g = CharacterA:GetChildren()
            for i = 1, #g do
                if g[i].ClassName == "Part" then
                    g[i].Anchored = false
                end
            end
        end
    end
    
    
    --//=================================\\
    --||	WRAP THE WHOLE SCRIPT UP
    --\\=================================//
    
    Humanoid.Changed:connect(function(Jump)
        if Jump == "Jump" and (Disable_Jump == true) then
            Humanoid.Jump = false
        end
    end)
    
    local GLITCH = 0
    
    local CONNECT = nil
    
    while true do
        Swait()
        ANIMATE.Parent = nil
        if Character:FindFirstChildOfClass("Humanoid") == nil then
            Humanoid = IT("Humanoid",Character)
        end
        for _,v in next, Humanoid:GetPlayingAnimationTracks() do
            v:Stop();
        end
    local ADD = Humanoid.WalkSpeed*2
    local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
    local TORSOVERTICALVELOCITY = RootPart.Velocity.y
    local NameClan = 0
    local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
    local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
        SINE = SINE + CHANGE
        if ANIM == "Walk" and TORSOVELOCITY > 1 then
            RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(-TORSOVERTICALVELOCITY), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
        elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
            RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
        end
        if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
            ANIM = "Jump"
            if ATTACK == false then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
        end
        elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
            ANIM = "Fall"
            if ATTACK == false then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
        end
        elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
            ANIM = "Idle"
            if ATTACK == false then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 25)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(8 * SIN(SINE / 26)), RAD(-25 - 8.5 * SIN(SINE / 25))), 0.15 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(8 * SIN(SINE / 26)), RAD(-10), RAD(6 + 8.5 * SIN(SINE / 25))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8, 0.4, -0.7) * ANGLES(RAD(90), RAD(0), RAD(86)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        end
        elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
            ANIM = "Walk"
            if ATTACK == false then
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(16), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-16 - 8.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-10), RAD(6)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-(8+(ADD*1.25))* COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-22 * COS(SINE / (WALKSPEEDVALUE)))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
            end
        end
        unanchor()
        Humanoid.MaxHealth = "inf"
        Humanoid.Health = "inf"
        if Rooted == false then
            Disable_Jump = false
            Humanoid.WalkSpeed = Speed
        elseif Rooted == true then
            Disable_Jump = true
            Humanoid.WalkSpeed = 0
        end
                BMUSIC.SoundId = "rbxassetid://" .. SONGID
        BMUSIC.Looped = true
        BMUSIC.Pitch = PITCH
        BMUSIC.Volume = VOLUME
        BMUSIC.Playing = true
        BMUSIC.EmitterSize = 35
        if BMUSIC.Parent ~= RootPart then
            print("Fixing music")
            BMUSIC = IT("Sound", RootPart)
            BMUSIC.SoundId = "rbxassetid://" .. SONGID
            BMUSIC.Looped = true
            BMUSIC.Pitch = PITCH
            BMUSIC.Volume = VOLUME
            BMUSIC.Playing = true
            BMUSIC.EmitterSize = 25
            BMUSIC.TimePosition = TIMESTAMP
            FIXING = true
        elseif FIXING == false then
            TIMESTAMP = BMUSIC.TimePosition
        else
            FIXING = false
        end
        end
    
    --//=================================\\
    --\\=================================//
    
    
    
    
    
    --//====================================================\\--
    --||			  		 END OF SCRIPT
    --\\====================================================//--
    
end)

b:CreateButton("Krystal Dance",function()
    
    -----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]

--Alright so before i start rambling on about absolute nonsense, please subscribe to Pewdiepie on youtube! Help him defeat T-Series!--
--Also subscribe to Vengefulprogram--
--Krystal dance! The old famous script that sadly has been broken(sorta), i've decided to rework this thing because... nostalgia.--
--This is one of the first scripts i've ever ran on SB, seeing this back again really reminds me of how much of a noob i was.--
--Credits to Krystalteam, they made the original krystal dance! Be sure to respect them or else...--
--#makeoldscriptsgreatagain--

Player=game.Players.LocalPlayer
Character=Player.Character.Shiba
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
mouse = Player:GetMouse()
walking = false
jumping = false
attacking = false
firsttime = false
tauntdebounce = false
position = nil
MseGuide = true
running = false
settime = 0
sine = 0
t = 0
ws = 14
change = 1
combo1 = true
dancing = false
equip = false
dgs = 75
combo2 = false
switch1 = true
switch2 = false
firsttime2 = false
combo3 = false
gunallowance = false
shooting = false
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

introsound = Instance.new("Sound",Head)
introsound.SoundId = "rbxassetid://236146895"
introsound.Volume = 8
introsound:Play()


fedora = Instance.new("Part",Character)
fedora.Size = Vector3.new(2,2,2)
fedora.CFrame = Head.CFrame
fedora.CanCollide = false
fedora.Transparency = 1
fedoraweld = Instance.new("Weld",fedora)
fedoraweld.Part0 = fedora
fedoraweld.Part1 = Head
fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)
mfedora = Instance.new("SpecialMesh", fedora)
mfedora.MeshType = "FileMesh"
mfedora.Scale = Vector3.new(.97, .97, .97)
mfedora.MeshId,mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'

shades = Instance.new("Part",Character)
shades.Size = Vector3.new(2,2,2)
shades.CFrame = Head.CFrame
shades.CanCollide = false
shades.Transparency = 1
shadesweld = Instance.new("Weld",shades)
shadesweld.Part0 = shades
shadesweld.Part1 = Head
shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.2,.15)
mshades = Instance.new("SpecialMesh", shades)
mshades.MeshType = "FileMesh"
mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
mshades.MeshId,mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360','http://www.roblox.com/asset/?id=1577349'

coroutine.wrap(function()
while wait() do
Head.face.Texture = "rbxasset://textures/face.png"
hum.WalkSpeed = ws
end
end)()
coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		

end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


intro = true
ws = 0

bigfedora = Instance.new("Part",Character)
bigfedora.Size = Vector3.new(2,2,2)
bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
bigfedora.CanCollide = false
bigfedora.Anchored = true
bigfedora.Name = "mbigf"
mbigfedora = Instance.new("SpecialMesh", bigfedora)
mbigfedora.MeshType = "FileMesh"
mbigfedora.Scale = Vector3.new(6, 7, 7)
mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
for i = 1, 60 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
swait()
end
for i = 1, 50 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
swait()
end
zmc = 0
for i = 1, 29 do
zmc = zmc + 2
mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
swait()
end
bigfedora:Remove()

ws = 14

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP

so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='k' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jam = Instance.new("Sound",Torso)
jam.SoundId = "rbxassetid://665751753"
jam.Volume = 8
jam.Looped = true
jam.TimePosition = 22.3
jam:Play()
lol90 = 0
coroutine.wrap(function()
while dancing do
lol90 = lol90 + 11
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
swait()
end
ws = 14
jam:Remove()
ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='j' then
if dancing then
dancing = false
else
dancing = true
ws = 3
change = .5
attacking = true
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
herecomesthemoney = Instance.new("Sound",Torso)
herecomesthemoney.Pitch = 1
herecomesthemoney.SoundId = "rbxassetid://2426693638"
herecomesthemoney.Volume = 8
herecomesthemoney.Looped = true
herecomesthemoney:Play()
robuxpile = Instance.new("Part",Torso)
robuxpile.Size = Vector3.new(1,1,1)
robuxpile.CFrame = LeftArm.CFrame
robuxpile.CanCollide = false
robuxpileweld = Instance.new("Weld",robuxpile)
robuxpileweld.Part0 = robuxpile
robuxpileweld.Part1 = Torso
robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
mrobuxpile = Instance.new("SpecialMesh", robuxpile)
mrobuxpile.MeshType = "FileMesh"
mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
coroutine.wrap(function()
coroutine.wrap(function()
while wait(.35) do
if not dancing then break end
local robux = Instance.new("Part",Torso)
robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
robux.Anchored = false
robux.CanCollide = true
robux.Size = Vector3.new(1,1,1)
removeuseless:AddItem(robux,4)
mrobux = Instance.new("SpecialMesh", robux)
mrobux.MeshType = "FileMesh"
mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
bov = Instance.new("BodyVelocity",robux)
bov.maxForce = Vector3.new(99999,99999,99999)
robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
bov.velocity = robux.CFrame.lookVector*45
removeuseless:AddItem(bov,.1)
end
end)()
while dancing do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
swait()
end
ws = 14
removeuseless:AddItem(g1,.001)
robuxpile:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='h' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jellyfishjam = Instance.new("Sound",Torso)
jellyfishjam.SoundId = "rbxassetid://840189092"
jellyfishjam.Volume = 8
jellyfishjam.Looped = true
jellyfishjam.TimePosition = 14.8
jellyfishjam:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='g' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
deadmau7 = Instance.new("Sound",Torso)
deadmau7.SoundId = "rbxassetid://168166611"
deadmau7.Volume = 8
deadmau7.Looped = true
deadmau7:Play()
coroutine.wrap(function()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
swait()
end
end)()
while dancing do
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
swait()
end
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
deadmau7:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='f' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
bennyhill = Instance.new("Sound",Torso)
bennyhill.SoundId = "rbxassetid://138211362"
bennyhill.Volume = 8
bennyhill.Looped = true
bennyhill:Play()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
swait()
end
ws = 14
bennyhill:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='p' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
barrelspin = 0
barrelrollsound = Instance.new("Sound",Torso)
barrelrollsound.SoundId = "rbxassetid://505320170"
barrelrollsound.Volume = 8
barrelrollsound.Looped = true
barrelrollsound:Play()
barrol = Instance.new("Part",Torso)
barrol.Size = Vector3.new(1,1,1)
barrol.CFrame = Torso.CFrame
barrol.CanCollide = false
barrolweld = Instance.new("Weld",barrol)
barrolweld.Part0 = barrol
barrolweld.Part1 = Torso
barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
mbarrol = Instance.new("SpecialMesh", barrol)
mbarrol.MeshType = "FileMesh"
mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
swait()
end
ws = 14
barrol:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='q' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
spinningmove = 0
dbwouldlovethis = Instance.new("Sound",Torso)
dbwouldlovethis.SoundId = "rbxassetid://1532157598"
dbwouldlovethis.Volume = 8
dbwouldlovethis.Looped = true
dbwouldlovethis:Play()
attacking = true
coroutine.wrap(function()
while dancing do
spinningmove = spinningmove + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
swait()
end
ws = 14
dbwouldlovethis:Remove()
attacking = false
end)()
end
end
end)


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='u' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
slavdance = Instance.new("Sound",Torso)
slavdance.SoundId = "rbxassetid://2341226836"
slavdance.Volume = 6
slavdance.Looped = true
slavdance:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
swait()
end
ws = 14
slavdance:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='y' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
walkforward = 0
walkrotation = 0
attacking = true
truelegend = Instance.new("Sound",Torso)
truelegend.SoundId = "rbxassetid://487872908"
truelegend.TimePosition = 13.98
truelegend.Volume = 8
truelegend.Looped = true
truelegend:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward + .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward - .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
swait()
end
ws = 14
truelegend:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
plummusic = Instance.new("Sound",Torso)
plummusic.Volume = 8
plummusic.Looped = true
plummusic.SoundId = "rbxassetid://2526093213"
plummusic:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
swait()
end
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
swait()
end
swait()
end
ws = 14
plummusic:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
mrozo = Instance.new("Sound",Torso)
mrozo.Volume = 8
mrozo.SoundId = "rbxassetid://335701357"
mrozo.Looped = true
mrozo.TimePosition = 10
mrozo:Play()
coroutine.wrap(function()
while dancing do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
swait()
end
mrozo:Remove()
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='r' then
if dancing then
dancing = false
else
ws = 6
recordbaby = 0
dancing = true
change = .5
attacking = true
spinme = Instance.new("Sound",Torso)
spinme.Volume = 8
spinme.SoundId = "rbxassetid://145799973"
spinme.Looped = true
spinme:Play()
coroutine.wrap(function()
while dancing do
recordbaby = recordbaby + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
swait()
end
spinme:Remove()
ws = 14
attacking = false
end)()
end
end
end)

function ray(pos, dir, rang, ignoredesc)
	return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
end

function ray2(startpos, endpos, distance, ignore)
local dir = CFrame.new(startpos,endpos).lookVector
return ray(startpos, dir, distance, ignore)
end

checks1 = coroutine.wrap(function() -------Checks
while true do
hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
if Root.Velocity.y > 1 then
position = "Jump"
elseif Root.Velocity.y < -1 then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 then
position = "Idle"
elseif Root.Velocity.Magnitude > 2 then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
elseif position == "Falling" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
elseif position == "Walking" and attacking == false and running == false then
change = 1.2
walking = true
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
elseif position == "Idle" and attacking == false and running == false then
change = .5
spin = true
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
elseif position == "Running" and attacking == false then
change = 1
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
warn("Back from the past to dance the dance. Made by Supr14(Credits to Krystalteam).")
end)

b:CreateButton("Ender", function()
    -----------------------
--[[ Organization : Insanity ]]--
--[[ Name : Ender (Thou who collects the souls of innocents) ]]--
--[[ Creator / Captain : DATA RESTRICTED ]]--
-------------------------------------------------------
--A script By makhail07

--Discord Creterisk#2958

--This script is a fucking mistake have fun skids
-------------------------------------------------------
local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}


loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()
--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
local char = plr.Character.Shiba
local hum = char.Humanoid
local ra = char["Right Arm"]
local la= char["Left Arm"]
local rl= char["Right Leg"]
local ll = char["Left Leg"]
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor


-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}



-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = 0
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
			
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------

function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = Instance.new("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end

function Eviscerate(dude)
print("no")
end
function SphereAura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
                        rng.BrickColor = BrickColor.random()
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end
function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)

end)
wait(1.2)
while soul do
	swait()
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
--[[
		Thanks for using Build-To-Lua by jarredbcv.
]]--

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	
Gaunty = New("Model",char,"Gaunty",{})
Handle = New("Part",Gaunty,"Handle",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Handle,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595344, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161155701, 0.603512526, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595367, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471122265, 0.600126028, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 3.62595415, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812294, 0.606899738, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765471, 3.62595463, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.448780537, 0.610177517, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.459102631, -0.489744425, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765627, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149136543, -0.486357927, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765537, 2.53595448, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160831451, -0.48297143, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.53595424, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460799217, -0.479694128, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64553881, -77.6613617, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(-0.00235080719, 0.624869347, 0.00694274902, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 3.73544312, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.000443935394, 0.714845657, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.52554965, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00275993347, 0.504870415, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553746, -77.6613541, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00966835022, -0.465003252, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480494, 2.43554902, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0147790909, -0.585001707, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595558, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00464963913, 0.606931448, -0.149864197, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595606, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00278997421, 0.603431463, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595654, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00554895401, 0.600307703, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00736999512, -0.482939243, -0.161483765, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595614, -78.1079254, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0101289749, -0.479815245, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765547, 3.62595677, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00554943085, 0.600307941, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 3.62595701, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00278949738, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.000350952148, 0.606987953, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00311040878, 0.61011219, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0123701096, -0.482883692, -0.161437988, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595686, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00647068024, -0.489563227, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595701, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471121788, 0.600129128, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.62595725, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161154747, 0.603516102, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765442, 3.62595773, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812771, 0.606903076, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765375, 3.6259582, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.44878149, 0.610180855, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595781, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460801125, -0.47969079, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160833359, -0.48296833, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765341, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149133682, -0.486355066, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765383, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.4591012, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203499, 3.4509573, -77.7865677, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00760126114, 0.431732178, -0.120269775, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203451, 3.45095778, -77.5215683, -1.0000006, -6.18456397e-10, -9.12696123e-08, 6.18456397e-10, 1.0000006, -4.65661287e-09, 8.38190317e-08, 4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, -1),C1 = CFrame.new(0.00508022308, 0.428877592, 0.144706726, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 2.81095791, -77.7865601, -1.0000006, 8.81700544e-08, 3.7252903e-09, -8.69331416e-08, -1.0000006, 4.65661287e-09, -3.7252903e-09, -4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, -8.74227766e-08, 0, 8.74227766e-08, -1, 0, 0, 0, 1),C1 = CFrame.new(0.0146594048, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 2.8209579, -77.5215607, 1.0000006, -8.69331416e-08, 8.38190317e-08, -8.81700544e-08, -1.0000006, -4.65661287e-09, 9.12696123e-08, -4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, -8.74227766e-08, 8.74227766e-08, -8.74227766e-08, -1, -7.64274186e-15, 8.74227766e-08, 0, -1),C1 = CFrame.new(0.0120282173, -0.201047897, 0.137992859, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Wedge = New("WedgePart",Gaunty,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113148, -77.6620178, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.0109024048, 1.04061508, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})

Gaunty2 = New("Model",char,"Gaunty2",{})
Handle2 = New("Part",Gaunty2,"Handle2",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Handle2,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595367, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161155701, 0.603512764, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595439, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471122265, 0.600126743, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765394, 3.6259551, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813248, 0.606900692, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765375, 3.62595558, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.44878149, 0.610178471, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765621, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459103584, -0.489744902, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765722, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149137497, -0.486358404, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 2.53595448, -77.6579514, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160831928, -0.482971191, -3.05175781e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.535954, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460799217, -0.479694366, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64554, -77.661377, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(-0.00235033035, 0.624870777, 0.00692749023, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.6649003, 3.73544407, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.000444412231, 0.714846611, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.5255506, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00275993347, 0.504871368, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553699, -77.6613541, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00966835022, -0.465003729, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480589, 2.43554854, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0147781372, -0.585002184, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265511, 3.6259563, -77.8179169, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00464916229, 0.606932163, -0.149848938, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765451, 3.62595701, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00278902054, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595749, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554895401, 0.600308895, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00736999512, -0.482939243, -0.161468506, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595567, -78.1079254, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0101289749, -0.479815722, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554847717, 0.600308895, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765404, 3.62595797, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0027885437, 0.603433609, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.6259594, -77.8179321, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.000351905823, 0.606989861, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.62595844, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00311136246, 0.610113144, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0123701096, -0.48288393, -0.161422729, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595662, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00647068024, -0.489563465, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595797, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471121788, 0.600130081, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.6259582, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161154747, 0.603517056, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765347, 3.62595868, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813725, 0.60690403, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.2176528, 3.62595916, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.448782444, 0.610181808, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595757, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460801601, -0.479691029, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160833836, -0.48296833, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765436, 2.5359571, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149134636, -0.486355305, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 2.53595734, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459102154, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 3.45095801, -77.7865524, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00760221481, 0.431732655, -0.120254517, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 3.45095849, -77.521553, -1.00000179, -2.26282282e-09, -9.87201929e-08, 2.28465069e-09, 1.00000179, -1.39698386e-08, 7.63684511e-08, 1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, 1.45519152e-09, 8.00937414e-08, -1.44063961e-09, 1.00000119, 9.31322575e-09, -9.49949026e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.00508117676, 0.428878307, 0.144721985, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203308, 2.81095791, -77.7865601, -1.00000179, 8.98216967e-08, 1.11758709e-08, -8.52742232e-08, -1.00000179, 1.39698386e-08, -1.11758709e-08, -1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, -8.61036824e-08, -7.4505806e-09, 8.89922376e-08, -1.00000119, -9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0146603584, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.6620326, 2.82095814, -77.5215454, 1.00000179, -8.52887752e-08, 7.63684511e-08, -8.98362487e-08, -1.00000179, -1.39698386e-08, 9.87201929e-08, -1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -8.89995135e-08, 9.49949026e-08, -8.61109584e-08, -1.00000119, -9.31322575e-09, 8.00937414e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.012029171, -0.201047897, 0.138008118, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Wedge = New("WedgePart",Gaunty2,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113243, -77.6620178, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.0109024048, 1.04061604, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})


NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local HW = NewInstance('Motor', char, {Part0 = ra, Part1 = Handle, C0 = CF(0,-.51,0)})
local HW2 = NewInstance('Motor', char, {Part0 = la, Part1 = Handle2, C0 = CF(0,-.51,0) * angles(Rad(0),Rad(180),Rad(0))})

for _,v in next, Gaunty:children() do
	v.CanCollide = false
end
for _,v in next, Gaunty2:children() do
	v.CanCollide = false
end
local all, last = {}, nil
ArmourParts = {}
NeonParts = {}
function scan(p)
  for _, v in pairs(p:GetChildren()) do
    if v:IsA("BasePart") then
      if v.BrickColor == BrickColor.new("Black") then
        table.insert(ArmourParts, v)
      end
      if v.BrickColor == BrickColor.new("Institutional white") then
        table.insert(NeonParts, v)
      end
      if last then
        local w = Instance.new("Weld")
        w.Part0, w.Part1 = last, v
        w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
        w.Parent = last
      end
      table.insert(all, v)
      last = v
    end
    scan(v)
  end
end
scan(Gaunty)
local all2, last2 = {}, nil
ArmourParts2 = {}
NeonParts2 = {}
function scan2(p)
  for _, v in pairs(p:GetChildren()) do
    if v:IsA("BasePart") then
      if v.BrickColor == BrickColor.new("Black") then
        table.insert(ArmourParts2, v)
      end
      if v.BrickColor == BrickColor.new("Institutional white") then
        table.insert(NeonParts2, v)
      end
      if last2 then
        local w = Instance.new("Weld")
        w.Part0, w.Part1 = last2, v
        w.C0 = v.CFrame:toObjectSpace(last2.CFrame):inverse()
        w.Parent = last2
      end
      table.insert(all2, v)
      last2 = v
    end
    scan2(v)
  end
end
scan2(Gaunty2)
for i, v in pairs(ArmourParts) do
     v.BrickColor = BrickC("Black")
		end
for i, v in pairs(NeonParts) do
     v.BrickColor = BrickC("Really red")
      	end
for i, v in pairs(ArmourParts2) do
     v.BrickColor = BrickC("Black")
		end
for i, v in pairs(NeonParts2) do
     v.BrickColor = BrickC("Really red")
      	end
maincolor = BrickC("Really red")
-------------------------------------------------------
--Start Music Option--
-------------------------------------------------------
local Music = Instance.new("Sound",char)
Music.Volume = 2.5
Music.SoundId = "rbxassetid://550578451"
Music.Looped = true
Music.Pitch = 1 --Pitcher
Music:Play()
-------------------------------------------------------
--End Music Option--
-------------------------------------------------------
local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,35)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"

local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Ender"
tecks2.Font = "Garamond"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0,0,0)
tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2

function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		local tecks3 = Instance.new("TextLabel", naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = "SciFi"
		tecks3.TextSize = 30
		tecks3.TextStrokeTransparency = 0
		tecks3.TextColor3 = Color3.new(0, 0, 0)
		tecks3.TextStrokeColor3 = color
		tecks3.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
					tecks2.TextColor3 = BrickColor.random().Color
					tecks3.TextStrokeColor3 = BrickColor.random().Color
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks3.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
				tecks3.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", char, 0.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			tecks3.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		local randomrot = math.random(1, 2)
		if randomrot == 1 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation - 0.75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks2.TextTransparency = tecks2.TextTransparency + 0.04
				tecks3.Rotation = tecks2.Rotation + 0.75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks3.TextTransparency = tecks2.TextTransparency + 0.04
			end
		elseif randomrot == 2 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation + 0.75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks2.TextTransparency = tecks2.TextTransparency + 0.04
				tecks3.Rotation = tecks2.Rotation - 0.75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks3.TextTransparency = tecks2.TextTransparency + 0.04
			end
		end
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
local sine=0
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
  local Hitboxpart = Instance.new("Part", EffectModel)
  RemoveOutlines(Hitboxpart)
  Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
  Hitboxpart.CanCollide = false
  Hitboxpart.Transparency = 1
  Hitboxpart.Anchored = true
  Hitboxpart.CFrame = Pose
  game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
  MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
end
wait2 = false
combo = 1
mouse.Button1Down:connect(function(key)
  if attack == false then
    attack = true
    hum.WalkSpeed = 3.01
    if combo == 1 and wait2 == false then
      wait2 = true
		for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-65)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(-65)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
		  end
		CreateSound("138097048", ra, 3, .8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(55)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(40)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
      end
      combo = 2
    end
 	if combo == 2 and wait2 == false then
      wait2 = true
   for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(65)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(65)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
		  end
		CreateSound("138097048", ra, 3, .8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-55)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(-40)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
      end
      combo = 3
    end
   if combo == 3 and wait2 == false then
	wait2 = true
    for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
      end
	CreateSound("138097048", ra, 3, .8)
      HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(96), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
      end
		Effects.Sphere.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 1.1, 1.1, 1.1, 0.02)
		Effects.Ring.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 2, 2, 2, 1.1, 1.1, 1.1, 0.03)
		for i = 0, 2 do
			SphereAura(2, 0.2, "Add", ra.CFrame * CFrame.Angles(math.rad(-90 + math.random(-20, 20)), math.rad(math.random(-20, 20)), math.rad(math.random(-20, 20))), 0.5, 0.5, 5, -0.005, maincolor, 0)
			end
		coroutine.resume(coroutine.create(function() 
		for i = 0,1.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	  end))
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
	for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(25), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
      end
      combo = 4
    end
	if combo == 4 and wait2 == false then
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
	end
SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
		SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
        Effects.Sphere.Create(maincolor, root.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 15.1, 15.1, 15.1, 0.01)
	CreateSound("331666100", char, 10, 1)
        for i, v in pairs(FindNearestHead(tors.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			SoulSteal(v)
			Eviscerate(v)
		end
	end
	coroutine.resume(coroutine.create(function() 
		for i = 0,1.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	  end))
	for i = 1,4.7,0.1 do
	rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1.4 + 0.1 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(0)), 0.15)
	tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35), Rad(0), Rad(0)), 0.3)
	RH.C0 = clerp(RH.C0, CF(1, .4 - 0.1 * Cos(sine / 20), -.6 + 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(45)), 0.15)
	LH.C0 = clerp(LH.C0, CF(-1, -0.6 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
	RW.C0 = clerp(RW.C0, CF(1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(-34)), 0.1)
	LW.C0 = clerp(LW.C0, CF(-1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(34)), 0.1)
	end
      wait(.6)
	combo = 1
	end
    hum.WalkSpeed = 16
    wait2 = false
    attack = false
	end
end)
function Destruction()
	attack = true
	local Ring1 = Instance.new("Part", char)
	Ring1.Anchored = true
	Ring1.BrickColor = maincolor
	Ring1.CanCollide = false
	Ring1.FormFactor = 3
	Ring1.Name = "Ring"
	Ring1.Material = "Neon"
	Ring1.Size = Vector3.new(1, 0.05, 1)
	Ring1.Transparency = 1
	Ring1.TopSurface = 0
	Ring1.BottomSurface = 0
	local Ring1Mesh = Instance.new("SpecialMesh", Ring1)
	Ring1Mesh.MeshType = "Brick"
	Ring1Mesh.Name = "SizeMesh"
	Ring1Mesh.Scale = Vector3.new(0, 1, 0)
	local InnerRing1 = Ring1:Clone()
	InnerRing1.Parent = char
	InnerRing1.Transparency = 0
	InnerRing1.BrickColor = BrickColor.new("New Yeller")
	InnerRing1.Size = Vector3.new(1, 1, 1)
	local InnerRing1Mesh = InnerRing1.SizeMesh
	InnerRing1Mesh.Scale = Vector3.new(0, 0, 0)
	InnerRing1Mesh.MeshType = "Sphere"
	Ring1:Destroy()
	for i = 0, 5, 0.1 do
		swait()
		SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
		SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, BrickC("Institutional white"), 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-4.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-12.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-25)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(25)), 0.1)
		root.CFrame = FaceMouse()[1]
	end
	InnerRing1.Transparency = 1
	InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 5
	CreateSound("294188875", char, 2.3, 1)
	local a = IT("Part", char)
	a.Name = "Direction"
	a.Anchored = true
	a.BrickColor = maincolor
	a.Material = "Neon"
	a.Transparency = 0
	a.Shape = "Cylinder"
	a.CanCollide = false
	local a2 = IT("Part", char)
	a2.Name = "Direction"
	a2.Anchored = true
	a2.BrickColor = maincolor
	a2.Color = maincolor.Color
	a2.Material = "Neon"
	a2.Transparency = 0.5
	a2.Shape = "Cylinder"
	a2.CanCollide = false
	local ba = IT("Part", char)
	ba.Name = "HitDirect"
	ba.Anchored = true
	ba.BrickColor = maincolor
	ba.Material = "Neon"
	ba.Transparency = 1
	ba.CanCollide = false
	local ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
	local ignore = char
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	a2.BottomSurface = 10
	a2.TopSurface = 10
	local distance = (InnerRing1.CFrame.p - position).magnitude
	a.Size = Vector3.new(distance, 1, 1)
	a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	a2.Size = Vector3.new(distance, 1, 1)
	a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
	a.CFrame = a.CFrame * angles(0, Rad(90), 0)
	a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
	game:GetService("Debris"):AddItem(a, 20)
	game:GetService("Debris"):AddItem(a2, 20)
	game:GetService("Debris"):AddItem(ba, 20)
	local msh = Instance.new("SpecialMesh", a)
	msh.MeshType = "Sphere"
	msh.Scale = Vector3.new(1, 25, 25)
	local msh2 = Instance.new("SpecialMesh", a2)
	msh2.MeshType = "Sphere"
	msh2.Scale = Vector3.new(1, 30, 30)
	for i = 0, 10, 0.1 do
		swait()
		root.CFrame = FaceMouse()[1]
		hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		a2.Color = maincolor.Color
		InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 4
		ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
		hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		distance = (InnerRing1.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
		a.CFrame = a.CFrame * angles(0, Rad(90), 0)
		a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
		msh.Scale = msh.Scale - Vector3.new(0, 0.25, 0.25)
		msh2.Scale = msh2.Scale - Vector3.new(0, 0.3, 0.3)
		SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
		SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
		for i, v in pairs(FindNearestHead(ba.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
			SoulSteal(v)
		end
	end
	end
	a:Destroy()
	a2:Destroy()
	ba:Destroy()
	InnerRing1:Destroy()
	attack = false
	hum.CameraOffset = Vector3.new(0,0,0)
end
function BURN_IN_HELL()
	attack = true
	chatfunc("BURN....", BrickColor.random().Color)
	for i = 0,5.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.3 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(-45 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(45 + 2.5 * Sin(sine / 20))), 0.1)
	end	
	chatfunc("IN....", BrickColor.random().Color)
	wait(2)
	CreateSound("331666100", char, 10, 1)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 35.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -3, 0), 2, 2, 2, 150.6, .4, 150.6, 0.05)
	chatfunc("HELL!!!!!", BrickColor.random().Color)
	for i, v in pairs(FindNearestHead(tors.CFrame.p, 52.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
			SoulSteal(v)
		end
	end
	coroutine.resume(coroutine.create(function() 
		for i = 0,2.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-3,3),Mrandom(-3,3),Mrandom(-3,3))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	end))
	for i = 0,3.7,0.1 do
		SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
		SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(-25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
	end
	wait(.6)
	CreateSound("907332997", hed, 10, 1)
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'f' then

		elseif key == 'r' then
			BURN_IN_HELL()
		elseif key == 't' then
			chatfunc("HM, HM, HAHAHAHAHAHA", BrickColor.random().Color)
			CreateSound("300208779", hed, 10, 1)
		end
	end
end)






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
hum.Animator.Parent = nil
while true do
	swait()
for i, v in pairs(NeonParts) do
     v.BrickColor = BrickColor.Random()
      	end
for i, v in pairs(NeonParts2) do
     v.BrickColor = BrickColor.Random()
      	end
maincolor = BrickColor.Random()
Music.Parent = char
tecks2.TextStrokeColor3 = maincolor.Color
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-10), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(15)),0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-15)),0.3)
				LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
				RH.C0=clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(30)),0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-30)),0.3)
				LH.C0 = clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
				RH.C0 = clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1.9
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(30), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35 - 2.5 * Sin(sine / 20)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-7.5), Rad(0), Rad(30)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-7.5), Rad(0), Rad(-30)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(15 + 7 * Sin(sine / 25))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(-15 - 7 * Sin(sine / 25))), 0.1)
			end
		elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(15 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(4 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(13 - 2.5 * Sin(sine / 7)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -0.925 - 0.5 * Cos(sine / 7) / 2, 0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 - 5 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(15)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1, -0.925 + 0.5 * Cos(sine / 7) / 2, -0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 + 5 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(-15)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(65)  * Cos(sine / 7) , Rad(0), Rad(10 + 7 * Sin(sine / 7)) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(-65)  * Cos(sine / 7) , Rad(0), Rad(-10 - 7 * Sin(sine / 7)) + la.RotVelocity.Y / 75), 0.1)
			end
		end
	end
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
end)
